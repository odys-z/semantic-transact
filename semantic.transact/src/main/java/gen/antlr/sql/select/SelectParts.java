// Generated from SelectParts.g4 by ANTLR 4.7.1
package gen.antlr.sql.select;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.v4.runtime.tree.*;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast"})
public class SelectParts extends Parser {
	static { RuntimeMetaData.checkVersion("4.7.1", RuntimeMetaData.VERSION); }

	protected static final DFA[] _decisionToDFA;
	protected static final PredictionContextCache _sharedContextCache =
		new PredictionContextCache();
	public static final int
		ABSENT=1, ADD=2, AES=3, ALL=4, ALLOW_CONNECTIONS=5, ALLOW_MULTIPLE_EVENT_LOSS=6, 
		ALLOW_SINGLE_EVENT_LOSS=7, ALTER=8, AND=9, ANONYMOUS=10, ANY=11, APPEND=12, 
		APPLICATION=13, AS=14, ASC=15, ASYMMETRIC=16, ASYNCHRONOUS_COMMIT=17, 
		AUTHORIZATION=18, AUTHENTICATION=19, AUTOMATED_BACKUP_PREFERENCE=20, AUTOMATIC=21, 
		AVAILABILITY_MODE=22, BACKSLASH=23, BACKUP=24, BEFORE=25, BEGIN=26, BETWEEN=27, 
		BLOCK=28, BLOCKSIZE=29, BLOCKING_HIERARCHY=30, BREAK=31, BROWSE=32, BUFFER=33, 
		BUFFERCOUNT=34, BULK=35, BY=36, CACHE=37, CALLED=38, CASCADE=39, CASE=40, 
		CERTIFICATE=41, CHANGETABLE=42, CHANGES=43, CHECK=44, CHECKPOINT=45, CHECK_POLICY=46, 
		CHECK_EXPIRATION=47, CLASSIFIER_FUNCTION=48, CLOSE=49, CLUSTER=50, CLUSTERED=51, 
		COALESCE=52, COLLATE=53, COLUMN=54, COMPRESSION=55, COMMIT=56, COMPUTE=57, 
		CONFIGURATION=58, CONSTRAINT=59, CONTAINMENT=60, CONTAINS=61, CONTAINSTABLE=62, 
		CONTEXT=63, CONTINUE=64, CONTINUE_AFTER_ERROR=65, CONTRACT=66, CONTRACT_NAME=67, 
		CONVERSATION=68, CONVERT=69, COPY_ONLY=70, CREATE=71, CROSS=72, CURRENT=73, 
		CURRENT_DATE=74, CURRENT_TIME=75, CURRENT_TIMESTAMP=76, CURRENT_USER=77, 
		CURSOR=78, CYCLE=79, DATA=80, DATA_COMPRESSION=81, DATA_SOURCE=82, DATABASE=83, 
		DATABASE_MIRRORING=84, DBCC=85, DEALLOCATE=86, DECLARE=87, DEFAULT=88, 
		DEFAULT_DATABASE=89, DEFAULT_SCHEMA=90, DELETE=91, DENY=92, DESC=93, DIAGNOSTICS=94, 
		DIFFERENTIAL=95, DISK=96, DISTINCT=97, DISTRIBUTED=98, DOUBLE=99, DOUBLE_BACK_SLASH=100, 
		DOUBLE_FORWARD_SLASH=101, DROP=102, DTC_SUPPORT=103, DUMP=104, ELSE=105, 
		ENABLED=106, END=107, ENDPOINT=108, ERRLVL=109, ESCAPE=110, ERROR=111, 
		EVENT=112, EVENTDATA=113, EVENT_RETENTION_MODE=114, EXCEPT=115, EXECUTABLE_FILE=116, 
		EXECUTE=117, EXISTS=118, EXPIREDATE=119, EXIT=120, EXTENSION=121, EXTERNAL=122, 
		EXTERNAL_ACCESS=123, FAILOVER=124, FAILURECONDITIONLEVEL=125, FAN_IN=126, 
		FETCH=127, FILE=128, FILENAME=129, FILLFACTOR=130, FILE_SNAPSHOT=131, 
		FOR=132, FORCESEEK=133, FORCE_SERVICE_ALLOW_DATA_LOSS=134, FOREIGN=135, 
		FREETEXT=136, FREETEXTTABLE=137, FROM=138, FULL=139, FUNCTION=140, GET=141, 
		GOTO=142, GOVERNOR=143, GRANT=144, GROUP=145, HAVING=146, HASHED=147, 
		HEALTHCHECKTIMEOUT=148, IDENTITY=149, IDENTITYCOL=150, IDENTITY_INSERT=151, 
		IF=152, IN=153, INCLUDE=154, INCREMENT=155, INDEX=156, INFINITE=157, INIT=158, 
		INNER=159, INSERT=160, INSTEAD=161, INTERSECT=162, INTO=163, IPV4_ADDR=164, 
		IPV6_ADDR=165, IS=166, ISNULL=167, JOIN=168, KERBEROS=169, KEY=170, KEY_PATH=171, 
		KEY_STORE_PROVIDER_NAME=172, KILL=173, LANGUAGE=174, LEFT=175, LIBRARY=176, 
		LIFETIME=177, LIKE=178, LINENO=179, LINUX=180, LISTENER_IP=181, LISTENER_PORT=182, 
		LOAD=183, LOCAL_SERVICE_NAME=184, LOG=185, MATCHED=186, MASTER=187, MAX_MEMORY=188, 
		MAXTRANSFER=189, MAXVALUE=190, MAX_DISPATCH_LATENCY=191, MAX_EVENT_SIZE=192, 
		MAX_SIZE=193, MAX_OUTSTANDING_IO_PER_VOLUME=194, MEDIADESCRIPTION=195, 
		MEDIANAME=196, MEMBER=197, MEMORY_PARTITION_MODE=198, MERGE=199, MESSAGE_FORWARDING=200, 
		MESSAGE_FORWARD_SIZE=201, MINVALUE=202, MIRROR=203, MUST_CHANGE=204, NATIONAL=205, 
		NEGOTIATE=206, NOCHECK=207, NOFORMAT=208, NOINIT=209, NONCLUSTERED=210, 
		NONE=211, NOREWIND=212, NOSKIP=213, NOUNLOAD=214, NO_CHECKSUM=215, NO_COMPRESSION=216, 
		NO_EVENT_LOSS=217, NOT=218, NOTIFICATION=219, NTLM=220, NULL=221, NULLIF=222, 
		OF=223, OFF=224, OFFSETS=225, OLD_PASSWORD=226, ON=227, ON_FAILURE=228, 
		OPEN=229, OPENDATASOURCE=230, OPENQUERY=231, OPENROWSET=232, OPENXML=233, 
		OPTION=234, OR=235, ORDER=236, OUTER=237, OVER=238, PAGE=239, PARAM_NODE=240, 
		PARTIAL=241, PASSWORD=242, PERCENT=243, PERMISSION_SET=244, PER_CPU=245, 
		PER_DB=246, PER_NODE=247, PIVOT=248, PLAN=249, PLATFORM=250, POLICY=251, 
		PRECISION=252, PREDICATE=253, PRIMARY=254, PRINT=255, PROC=256, PROCEDURE=257, 
		PROCESS=258, PUBLIC=259, PYTHON=260, R=261, RAISERROR=262, RAW=263, READ=264, 
		READTEXT=265, READ_WRITE_FILEGROUPS=266, RECONFIGURE=267, REFERENCES=268, 
		REGENERATE=269, RELATED_CONVERSATION=270, RELATED_CONVERSATION_GROUP=271, 
		REPLICATION=272, REQUIRED=273, RESET=274, RESTART=275, RESTORE=276, RESTRICT=277, 
		RESUME=278, RETAINDAYS=279, RETURN=280, RETURNS=281, REVERT=282, REVOKE=283, 
		REWIND=284, RIGHT=285, ROLLBACK=286, ROLE=287, ROWCOUNT=288, ROWGUIDCOL=289, 
		RSA_512=290, RSA_1024=291, RSA_2048=292, RSA_3072=293, RSA_4096=294, SAFETY=295, 
		RULE=296, SAFE=297, SAVE=298, SCHEDULER=299, SCHEMA=300, SCHEME=301, SECURITY=302, 
		SECURITYAUDIT=303, SELECT=304, SEMANTICKEYPHRASETABLE=305, SEMANTICSIMILARITYDETAILSTABLE=306, 
		SEMANTICSIMILARITYTABLE=307, SEQUENCE=308, SERVER=309, SERVICE=310, SERVICE_BROKER=311, 
		SERVICE_NAME=312, SESSION=313, SESSION_USER=314, SET=315, SETUSER=316, 
		SHUTDOWN=317, SID=318, SKIP_KEYWORD=319, SOFTNUMA=320, SOME=321, SOURCE=322, 
		SPECIFICATION=323, SPLIT=324, SQLDUMPERFLAGS=325, SQLDUMPERPATH=326, SQLDUMPERTIMEOUT=327, 
		STATISTICS=328, STATE=329, STATS=330, START=331, STARTED=332, STARTUP_STATE=333, 
		STOP=334, STOPPED=335, STOP_ON_ERROR=336, SUPPORTED=337, SYSTEM=338, SYSTEM_USER=339, 
		TABLE=340, TABLESAMPLE=341, TAPE=342, TARGET=343, TCP=344, TEXTSIZE=345, 
		THEN=346, TO=347, TOP=348, TRACK_CAUSALITY=349, TRAN=350, TRANSACTION=351, 
		TRANSFER=352, TRIGGER=353, TRUNCATE=354, TSEQUAL=355, UNCHECKED=356, UNION=357, 
		UNIQUE=358, UNLOCK=359, UNPIVOT=360, UNSAFE=361, UPDATE=362, UPDATETEXT=363, 
		URL=364, USE=365, USED=366, USER=367, VALUES=368, VARYING=369, VERBOSELOGGING=370, 
		VIEW=371, VISIBILITY=372, WAITFOR=373, WHEN=374, WHERE=375, WHILE=376, 
		WINDOWS=377, WITH=378, WITHIN=379, WITHOUT=380, WITNESS=381, WRITETEXT=382, 
		ABSOLUTE=383, ACCENT_SENSITIVITY=384, ACTION=385, ACTIVATION=386, ACTIVE=387, 
		ADDRESS=388, AES_128=389, AES_192=390, AES_256=391, AFFINITY=392, AFTER=393, 
		AGGREGATE=394, ALGORITHM=395, ALLOW_ENCRYPTED_VALUE_MODIFICATIONS=396, 
		ALLOW_SNAPSHOT_ISOLATION=397, ALLOWED=398, ANSI_NULL_DEFAULT=399, ANSI_NULLS=400, 
		ANSI_PADDING=401, ANSI_WARNINGS=402, APPLICATION_LOG=403, APPLY=404, ARITHABORT=405, 
		ASSEMBLY=406, AUDIT=407, AUDIT_GUID=408, AUTO=409, AUTO_CLEANUP=410, AUTO_CLOSE=411, 
		AUTO_CREATE_STATISTICS=412, AUTO_SHRINK=413, AUTO_UPDATE_STATISTICS=414, 
		AUTO_UPDATE_STATISTICS_ASYNC=415, AVAILABILITY=416, AVG=417, BACKUP_PRIORITY=418, 
		BEGIN_DIALOG=419, BIGINT=420, BINARY_BASE64=421, BINARY_CHECKSUM=422, 
		BINDING=423, BLOB_STORAGE=424, BROKER=425, BROKER_INSTANCE=426, BULK_LOGGED=427, 
		CALLER=428, CAP_CPU_PERCENT=429, CAST=430, CATALOG=431, CATCH=432, CHANGE_RETENTION=433, 
		CHANGE_TRACKING=434, CHECKSUM=435, CHECKSUM_AGG=436, CLEANUP=437, COLLECTION=438, 
		COLUMN_MASTER_KEY=439, COMMITTED=440, COMPATIBILITY_LEVEL=441, CONCAT=442, 
		CONCAT_NULL_YIELDS_NULL=443, CONTENT=444, CONTROL=445, COOKIE=446, COUNT=447, 
		COUNT_BIG=448, COUNTER=449, CPU=450, CREATE_NEW=451, CREATION_DISPOSITION=452, 
		CREDENTIAL=453, CRYPTOGRAPHIC=454, CURSOR_CLOSE_ON_COMMIT=455, CURSOR_DEFAULT=456, 
		DATE_CORRELATION_OPTIMIZATION=457, DATEADD=458, DATEDIFF=459, DATENAME=460, 
		DATEPART=461, DAYS=462, DB_CHAINING=463, DB_FAILOVER=464, DECRYPTION=465, 
		DEFAULT_DOUBLE_QUOTE=466, DEFAULT_FULLTEXT_LANGUAGE=467, DEFAULT_LANGUAGE=468, 
		DELAY=469, DELAYED_DURABILITY=470, DELETED=471, DENSE_RANK=472, DEPENDENTS=473, 
		DES=474, DESCRIPTION=475, DESX=476, DHCP=477, DIALOG=478, DIRECTORY_NAME=479, 
		DISABLE=480, DISABLE_BROKER=481, DISABLED=482, DISK_DRIVE=483, DOCUMENT=484, 
		DYNAMIC=485, ELEMENTS=486, EMERGENCY=487, EMPTY=488, ENABLE=489, ENABLE_BROKER=490, 
		ENCRYPTED_VALUE=491, ENCRYPTION=492, ENDPOINT_URL=493, ERROR_BROKER_CONVERSATIONS=494, 
		EXCLUSIVE=495, EXECUTABLE=496, EXIST=497, EXPAND=498, EXPIRY_DATE=499, 
		EXPLICIT=500, FAIL_OPERATION=501, FAILOVER_MODE=502, FAILURE=503, FAILURE_CONDITION_LEVEL=504, 
		FAST=505, FAST_FORWARD=506, FILEGROUP=507, FILEGROWTH=508, FILEPATH=509, 
		FILESTREAM=510, FILTER=511, FIRST=512, FIRST_VALUE=513, FOLLOWING=514, 
		FORCE=515, FORCE_FAILOVER_ALLOW_DATA_LOSS=516, FORCED=517, FORMAT=518, 
		FORWARD_ONLY=519, FULLSCAN=520, FULLTEXT=521, GB=522, GETDATE=523, GETUTCDATE=524, 
		GLOBAL=525, GO=526, GROUP_MAX_REQUESTS=527, GROUPING=528, GROUPING_ID=529, 
		HADR=530, HASH=531, HEALTH_CHECK_TIMEOUT=532, HIGH=533, HONOR_BROKER_PRIORITY=534, 
		HOURS=535, IDENTITY_VALUE=536, IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX=537, 
		IMMEDIATE=538, IMPERSONATE=539, IMPORTANCE=540, INCLUDE_NULL_VALUES=541, 
		INCREMENTAL=542, INITIATOR=543, INPUT=544, INSENSITIVE=545, INSERTED=546, 
		INT=547, IP=548, ISOLATION=549, JSON=550, KB=551, KEEP=552, KEEPFIXED=553, 
		KEY_SOURCE=554, KEYS=555, KEYSET=556, LAG=557, LAST=558, LAST_VALUE=559, 
		LEAD=560, LEVEL=561, LIST=562, LISTENER=563, LISTENER_URL=564, LOB_COMPACTION=565, 
		LOCAL=566, LOCATION=567, LOCK=568, LOCK_ESCALATION=569, LOGIN=570, LOOP=571, 
		LOW=572, MANUAL=573, MARK=574, MATERIALIZED=575, MAX=576, MAX_CPU_PERCENT=577, 
		MAX_DOP=578, MAX_FILES=579, MAX_IOPS_PER_VOLUME=580, MAX_MEMORY_PERCENT=581, 
		MAX_PROCESSES=582, MAX_QUEUE_READERS=583, MAX_ROLLOVER_FILES=584, MAXDOP=585, 
		MAXRECURSION=586, MAXSIZE=587, MB=588, MEDIUM=589, MEMORY_OPTIMIZED_DATA=590, 
		MESSAGE=591, MIN=592, MIN_ACTIVE_ROWVERSION=593, MIN_CPU_PERCENT=594, 
		MIN_IOPS_PER_VOLUME=595, MIN_MEMORY_PERCENT=596, MINUTES=597, MIRROR_ADDRESS=598, 
		MIXED_PAGE_ALLOCATION=599, MODE=600, MODIFY=601, MOVE=602, MULTI_USER=603, 
		NAME=604, NESTED_TRIGGERS=605, NEW_ACCOUNT=606, NEW_BROKER=607, NEW_PASSWORD=608, 
		NEXT=609, NO=610, NO_TRUNCATE=611, NO_WAIT=612, NOCOUNT=613, NODES=614, 
		NOEXPAND=615, NON_TRANSACTED_ACCESS=616, NORECOMPUTE=617, NORECOVERY=618, 
		NOWAIT=619, NTILE=620, NUMANODE=621, NUMBER=622, NUMERIC_ROUNDABORT=623, 
		OBJECT=624, OFFLINE=625, OFFSET=626, OLD_ACCOUNT=627, ONLINE=628, ONLY=629, 
		OPEN_EXISTING=630, OPTIMISTIC=631, OPTIMIZE=632, OUT=633, OUTPUT=634, 
		OWNER=635, PAGE_VERIFY=636, PARAMETERIZATION=637, PARTITION=638, PARTITIONS=639, 
		PARTNER=640, PATH=641, POISON_MESSAGE_HANDLING=642, POOL=643, PORT=644, 
		PRECEDING=645, PRIMARY_ROLE=646, PRIOR=647, PRIORITY=648, PRIORITY_LEVEL=649, 
		PRIVATE=650, PRIVATE_KEY=651, PRIVILEGES=652, PROCEDURE_NAME=653, PROPERTY=654, 
		PROVIDER=655, PROVIDER_KEY_NAME=656, QUERY=657, QUEUE=658, QUEUE_DELAY=659, 
		QUOTED_IDENTIFIER=660, RANGE=661, RANK=662, RC2=663, RC4=664, RC4_128=665, 
		READ_COMMITTED_SNAPSHOT=666, READ_ONLY=667, READ_ONLY_ROUTING_LIST=668, 
		READ_WRITE=669, READONLY=670, REBUILD=671, RECEIVE=672, RECOMPILE=673, 
		RECOVERY=674, RECURSIVE_TRIGGERS=675, RELATIVE=676, REMOTE=677, REMOTE_SERVICE_NAME=678, 
		REMOVE=679, REORGANIZE=680, REPEATABLE=681, REPLICA=682, REQUEST_MAX_CPU_TIME_SEC=683, 
		REQUEST_MAX_MEMORY_GRANT_PERCENT=684, REQUEST_MEMORY_GRANT_TIMEOUT_SEC=685, 
		REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT=686, RESERVE_DISK_SPACE=687, 
		RESOURCE=688, RESOURCE_MANAGER_LOCATION=689, RESTRICTED_USER=690, RETENTION=691, 
		ROBUST=692, ROOT=693, ROUTE=694, ROW=695, ROW_NUMBER=696, ROWGUID=697, 
		ROWS=698, SAMPLE=699, SCHEMABINDING=700, SCOPED=701, SCROLL=702, SCROLL_LOCKS=703, 
		SEARCH=704, SECONDARY=705, SECONDARY_ONLY=706, SECONDARY_ROLE=707, SECONDS=708, 
		SECRET=709, SECURITY_LOG=710, SEEDING_MODE=711, SELF=712, SEMI_SENSITIVE=713, 
		SEND=714, SENT=715, SERIALIZABLE=716, SESSION_TIMEOUT=717, SETERROR=718, 
		SHARE=719, SHOWPLAN=720, SIGNATURE=721, SIMPLE=722, SINGLE_USER=723, SIZE=724, 
		SMALLINT=725, SNAPSHOT=726, SPATIAL_WINDOW_MAX_CELLS=727, STANDBY=728, 
		START_DATE=729, STATIC=730, STATS_STREAM=731, STATUS=732, STDEV=733, STDEVP=734, 
		STOPLIST=735, STUFF=736, SUBJECT=737, SUM=738, SUSPEND=739, SYMMETRIC=740, 
		SYNCHRONOUS_COMMIT=741, SYNONYM=742, TAKE=743, TARGET_RECOVERY_TIME=744, 
		TB=745, TEXTIMAGE_ON=746, THROW=747, TIES=748, TIME=749, TIMEOUT=750, 
		TIMER=751, TINYINT=752, TORN_PAGE_DETECTION=753, TRANSFORM_NOISE_WORDS=754, 
		TRIPLE_DES=755, TRIPLE_DES_3KEY=756, TRUSTWORTHY=757, TRY=758, TSQL=759, 
		TWO_DIGIT_YEAR_CUTOFF=760, TYPE=761, TYPE_WARNING=762, UNBOUNDED=763, 
		UNCOMMITTED=764, UNKNOWN=765, UNLIMITED=766, USING=767, VALID_XML=768, 
		VALIDATION=769, VALUE=770, VAR=771, VARP=772, VIEW_METADATA=773, VIEWS=774, 
		WAIT=775, WELL_FORMED_XML=776, WITHOUT_ARRAY_WRAPPER=777, WORK=778, WORKLOAD=779, 
		XML=780, XMLDATA=781, XMLNAMESPACES=782, XMLSCHEMA=783, XSINIL=784, DOLLAR_ACTION=785, 
		SPACE=786, COMMENT=787, LINE_COMMENT=788, DOUBLE_QUOTE_ID=789, SINGLE_QUOTE=790, 
		SQUARE_BRACKET_ID=791, LOCAL_ID=792, DECIMAL=793, ID=794, QUOTED_URL=795, 
		QUOTED_HOST_AND_PORT=796, STRING=797, BINARY=798, FLOAT=799, REAL=800, 
		EQUAL=801, GREATER=802, LESS=803, EXCLAMATION=804, PLUS_ASSIGN=805, MINUS_ASSIGN=806, 
		MULT_ASSIGN=807, DIV_ASSIGN=808, MOD_ASSIGN=809, AND_ASSIGN=810, XOR_ASSIGN=811, 
		OR_ASSIGN=812, DOUBLE_BAR=813, DOT=814, UNDERLINE=815, AT=816, SHARP=817, 
		DOLLAR=818, LR_BRACKET=819, RR_BRACKET=820, COMMA=821, SEMI=822, COLON=823, 
		STAR=824, DIVIDE=825, MODULE=826, PLUS=827, MINUS=828, BIT_NOT=829, BIT_OR=830, 
		BIT_AND=831, BIT_XOR=832, IPV4_OCTECT=833;
	public static final int
		RULE_select_list = 0, RULE_select_list_elem = 1, RULE_as_column_alias = 2, 
		RULE_column_alias = 3, RULE_column_elem = 4, RULE_asterisk = 5, RULE_search_condition = 6, 
		RULE_search_condition_and = 7, RULE_search_condition_not = 8, RULE_predicate = 9, 
		RULE_expression_list = 10, RULE_expression = 11, RULE_function_call = 12, 
		RULE_aggregate_windowed_function = 13, RULE_func_proc_name = 14, RULE_full_column_name = 15, 
		RULE_table_name = 16, RULE_primitive_expression = 17, RULE_unary_operator_expression = 18, 
		RULE_bracket_expression = 19, RULE_constant_expression = 20, RULE_comparison_operator = 21, 
		RULE_assignment_operator = 22, RULE_null_notnull = 23, RULE_constant = 24, 
		RULE_sign = 25, RULE_id = 26;
	public static final String[] ruleNames = {
		"select_list", "select_list_elem", "as_column_alias", "column_alias", 
		"column_elem", "asterisk", "search_condition", "search_condition_and", 
		"search_condition_not", "predicate", "expression_list", "expression", 
		"function_call", "aggregate_windowed_function", "func_proc_name", "full_column_name", 
		"table_name", "primitive_expression", "unary_operator_expression", "bracket_expression", 
		"constant_expression", "comparison_operator", "assignment_operator", "null_notnull", 
		"constant", "sign", "id"
	};

	private static final String[] _LITERAL_NAMES = {
		null, "'ABSENT'", "'ADD'", "'AES'", "'ALL'", "'ALLOW_CONNECTIONS'", "'ALLOW_MULTIPLE_EVENT_LOSS'", 
		"'ALLOW_SINGLE_EVENT_LOSS'", "'ALTER'", null, "'ANONYMOUS'", "'ANY'", 
		"'APPEND'", "'APPLICATION'", "'AS'", "'ASC'", "'ASYMMETRIC'", "'ASYNCHRONOUS_COMMIT'", 
		"'AUTHORIZATION'", "'AUTHENTICATION'", "'AUTOMATED_BACKUP_PREFERENCE'", 
		"'AUTOMATIC'", "'AVAILABILITY_MODE'", "'\\'", "'BACKUP'", "'BEFORE'", 
		"'BEGIN'", "'BETWEEN'", "'BLOCK'", "'BLOCKSIZE'", "'BLOCKING_HIERARCHY'", 
		"'BREAK'", "'BROWSE'", "'BUFFER'", "'BUFFERCOUNT'", "'BULK'", "'BY'", 
		"'CACHE'", "'CALLED'", "'CASCADE'", "'CASE'", "'CERTIFICATE'", "'CHANGETABLE'", 
		"'CHANGES'", "'CHECK'", "'CHECKPOINT'", "'CHECK_POLICY'", "'CHECK_EXPIRATION'", 
		"'CLASSIFIER_FUNCTION'", "'CLOSE'", "'CLUSTER'", "'CLUSTERED'", "'COALESCE'", 
		"'COLLATE'", "'COLUMN'", "'COMPRESSION'", "'COMMIT'", "'COMPUTE'", "'CONFIGURATION'", 
		"'CONSTRAINT'", "'CONTAINMENT'", "'CONTAINS'", "'CONTAINSTABLE'", "'CONTEXT'", 
		"'CONTINUE'", "'CONTINUE_AFTER_ERROR'", "'CONTRACT'", "'CONTRACT_NAME'", 
		"'CONVERSATION'", null, "'COPY_ONLY'", "'CREATE'", "'CROSS'", "'CURRENT'", 
		"'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", 
		"'CURSOR'", "'CYCLE'", "'DATA'", "'DATA_COMPRESSION'", "'DATA_SOURCE'", 
		"'DATABASE'", "'DATABASE_MIRRORING'", "'DBCC'", "'DEALLOCATE'", "'DECLARE'", 
		"'DEFAULT'", "'DEFAULT_DATABASE'", "'DEFAULT_SCHEMA'", "'DELETE'", "'DENY'", 
		"'DESC'", "'DIAGNOSTICS'", "'DIFFERENTIAL'", "'DISK'", "'DISTINCT'", "'DISTRIBUTED'", 
		"'DOUBLE'", "'\\\\'", "'//'", "'DROP'", "'DTC_SUPPORT'", "'DUMP'", "'ELSE'", 
		"'ENABLED'", "'END'", "'ENDPOINT'", "'ERRLVL'", "'ESCAPE'", "'ERROR'", 
		"'EVENT'", null, "'EVENT_RETENTION_MODE'", "'EXCEPT'", "'EXECUTABLE_FILE'", 
		null, "'EXISTS'", "'EXPIREDATE'", "'EXIT'", "'EXTENSION'", "'EXTERNAL'", 
		"'EXTERNAL_ACCESS'", "'FAILOVER'", "'FAILURECONDITIONLEVEL'", "'FAN_IN'", 
		"'FETCH'", "'FILE'", "'FILENAME'", "'FILLFACTOR'", "'FILE_SNAPSHOT'", 
		"'FOR'", "'FORCESEEK'", "'FORCE_SERVICE_ALLOW_DATA_LOSS'", "'FOREIGN'", 
		"'FREETEXT'", "'FREETEXTTABLE'", "'FROM'", "'FULL'", "'FUNCTION'", "'GET'", 
		"'GOTO'", "'GOVERNOR'", "'GRANT'", "'GROUP'", "'HAVING'", "'HASHED'", 
		"'HEALTHCHECKTIMEOUT'", "'IDENTITY'", "'IDENTITYCOL'", "'IDENTITY_INSERT'", 
		"'IF'", "'IN'", "'INCLUDE'", "'INCREMENT'", "'INDEX'", "'INFINITE'", "'INIT'", 
		"'INNER'", "'INSERT'", "'INSTEAD'", "'INTERSECT'", "'INTO'", null, null, 
		"'IS'", "'ISNULL'", "'JOIN'", "'KERBEROS'", "'KEY'", "'KEY_PATH'", "'KEY_STORE_PROVIDER_NAME'", 
		"'KILL'", "'LANGUAGE'", "'LEFT'", "'LIBRARY'", "'LIFETIME'", "'LIKE'", 
		"'LINENO'", "'LINUX'", "'LISTENER_IP'", "'LISTENER_PORT'", "'LOAD'", "'LOCAL_SERVICE_NAME'", 
		"'LOG'", "'MATCHED'", "'MASTER'", "'MAX_MEMORY'", "'MAXTRANSFER'", "'MAXVALUE'", 
		"'MAX_DISPATCH_LATENCY'", "'MAX_EVENT_SIZE'", "'MAX_SIZE'", "'MAX_OUTSTANDING_IO_PER_VOLUME'", 
		"'MEDIADESCRIPTION'", "'MEDIANAME'", "'MEMBER'", "'MEMORY_PARTITION_MODE'", 
		"'MERGE'", "'MESSAGE_FORWARDING'", "'MESSAGE_FORWARD_SIZE'", "'MINVALUE'", 
		"'MIRROR'", "'MUST_CHANGE'", "'NATIONAL'", "'NEGOTIATE'", "'NOCHECK'", 
		"'NOFORMAT'", "'NOINIT'", "'NONCLUSTERED'", "'NONE'", "'NOREWIND'", "'NOSKIP'", 
		"'NOUNLOAD'", "'NO_CHECKSUM'", "'NO_COMPRESSION'", "'NO_EVENT_LOSS'", 
		"'NOT'", "'NOTIFICATION'", "'NTLM'", "'NULL'", "'NULLIF'", "'OF'", "'OFF'", 
		"'OFFSETS'", "'OLD_PASSWORD'", "'ON'", "'ON_FAILURE'", "'OPEN'", "'OPENDATASOURCE'", 
		"'OPENQUERY'", "'OPENROWSET'", "'OPENXML'", "'OPTION'", "'OR'", "'ORDER'", 
		"'OUTER'", "'OVER'", "'PAGE'", "'PARAM_NODE'", "'PARTIAL'", "'PASSWORD'", 
		"'PERCENT'", "'PERMISSION_SET'", "'PER_CPU'", "'PER_DB'", "'PER_NODE'", 
		"'PIVOT'", "'PLAN'", "'PLATFORM'", "'POLICY'", "'PRECISION'", "'PREDICATE'", 
		"'PRIMARY'", "'PRINT'", "'PROC'", "'PROCEDURE'", "'PROCESS'", "'PUBLIC'", 
		"'PYTHON'", "'R'", "'RAISERROR'", "'RAW'", "'READ'", "'READTEXT'", "'READ_WRITE_FILEGROUPS'", 
		"'RECONFIGURE'", "'REFERENCES'", "'REGENERATE'", "'RELATED_CONVERSATION'", 
		"'RELATED_CONVERSATION_GROUP'", "'REPLICATION'", "'REQUIRED'", "'RESET'", 
		"'RESTART'", "'RESTORE'", "'RESTRICT'", "'RESUME'", "'RETAINDAYS'", "'RETURN'", 
		"'RETURNS'", "'REVERT'", "'REVOKE'", "'REWIND'", "'RIGHT'", "'ROLLBACK'", 
		"'ROLE'", "'ROWCOUNT'", "'ROWGUIDCOL'", "'RSA_512'", "'RSA_1024'", "'RSA_2048'", 
		"'RSA_3072'", "'RSA_4096'", "'SAFETY'", "'RULE'", "'SAFE'", "'SAVE'", 
		"'SCHEDULER'", "'SCHEMA'", "'SCHEME'", "'SECURITY'", "'SECURITYAUDIT'", 
		"'SELECT'", "'SEMANTICKEYPHRASETABLE'", "'SEMANTICSIMILARITYDETAILSTABLE'", 
		"'SEMANTICSIMILARITYTABLE'", "'SEQUENCE'", "'SERVER'", "'SERVICE'", "'SERVICE_BROKER'", 
		"'SERVICE_NAME'", "'SESSION'", "'SESSION_USER'", "'SET'", "'SETUSER'", 
		"'SHUTDOWN'", "'SID'", "'SKIP'", "'SOFTNUMA'", "'SOME'", "'SOURCE'", "'SPECIFICATION'", 
		"'SPLIT'", "'SQLDUMPERFLAGS'", "'SQLDUMPERPATH'", "'SQLDUMPERTIMEOUTS'", 
		"'STATISTICS'", "'STATE'", "'STATS'", "'START'", "'STARTED'", "'STARTUP_STATE'", 
		"'STOP'", "'STOPPED'", "'STOP_ON_ERROR'", "'SUPPORTED'", "'SYSTEM'", "'SYSTEM_USER'", 
		"'TABLE'", "'TABLESAMPLE'", "'TAPE'", "'TARGET'", "'TCP'", "'TEXTSIZE'", 
		"'THEN'", "'TO'", "'TOP'", "'TRACK_CAUSALITY'", "'TRAN'", "'TRANSACTION'", 
		"'TRANSFER'", "'TRIGGER'", "'TRUNCATE'", "'TSEQUAL'", "'UNCHECKED'", "'UNION'", 
		"'UNIQUE'", "'UNLOCK'", "'UNPIVOT'", "'UNSAFE'", "'UPDATE'", "'UPDATETEXT'", 
		"'URL'", "'USE'", "'USED'", "'USER'", "'VALUES'", "'VARYING'", "'VERBOSELOGGING'", 
		"'VIEW'", "'VISIBILITY'", "'WAITFOR'", "'WHEN'", "'WHERE'", "'WHILE'", 
		"'WINDOWS'", "'WITH'", "'WITHIN'", "'WITHOUT'", "'WITNESS'", "'WRITETEXT'", 
		"'ABSOLUTE'", "'ACCENT_SENSITIVITY'", "'ACTION'", "'ACTIVATION'", "'ACTIVE'", 
		"'ADDRESS'", "'AES_128'", "'AES_192'", "'AES_256'", "'AFFINITY'", "'AFTER'", 
		"'AGGREGATE'", "'ALGORITHM'", "'ALLOW_ENCRYPTED_VALUE_MODIFICATIONS'", 
		"'ALLOW_SNAPSHOT_ISOLATION'", "'ALLOWED'", "'ANSI_NULL_DEFAULT'", "'ANSI_NULLS'", 
		"'ANSI_PADDING'", "'ANSI_WARNINGS'", "'APPLICATION_LOG'", "'APPLY'", "'ARITHABORT'", 
		"'ASSEMBLY'", "'AUDIT'", "'AUDIT_GUID'", "'AUTO'", "'AUTO_CLEANUP'", "'AUTO_CLOSE'", 
		"'AUTO_CREATE_STATISTICS'", "'AUTO_SHRINK'", "'AUTO_UPDATE_STATISTICS'", 
		"'AUTO_UPDATE_STATISTICS_ASYNC'", "'AVAILABILITY'", "'AVG'", "'BACKUP_PRIORITY'", 
		"'BEGIN_DIALOG'", "'BIGINT'", "'BINARY BASE64'", "'BINARY_CHECKSUM'", 
		"'BINDING'", "'BLOB_STORAGE'", "'BROKER'", "'BROKER_INSTANCE'", "'BULK_LOGGED'", 
		"'CALLER'", "'CAP_CPU_PERCENT'", null, "'CATALOG'", "'CATCH'", "'CHANGE_RETENTION'", 
		"'CHANGE_TRACKING'", "'CHECKSUM'", "'CHECKSUM_AGG'", "'CLEANUP'", "'COLLECTION'", 
		"'COLUMN_MASTER_KEY'", "'COMMITTED'", "'COMPATIBILITY_LEVEL'", "'CONCAT'", 
		"'CONCAT_NULL_YIELDS_NULL'", "'CONTENT'", "'CONTROL'", "'COOKIE'", "'COUNT'", 
		"'COUNT_BIG'", "'COUNTER'", "'CPU'", "'CREATE_NEW'", "'CREATION_DISPOSITION'", 
		"'CREDENTIAL'", "'CRYPTOGRAPHIC'", "'CURSOR_CLOSE_ON_COMMIT'", "'CURSOR_DEFAULT'", 
		"'DATE_CORRELATION_OPTIMIZATION'", "'DATEADD'", "'DATEDIFF'", "'DATENAME'", 
		"'DATEPART'", "'DAYS'", "'DB_CHAINING'", "'DB_FAILOVER'", "'DECRYPTION'", 
		null, "'DEFAULT_FULLTEXT_LANGUAGE'", "'DEFAULT_LANGUAGE'", "'DELAY'", 
		"'DELAYED_DURABILITY'", "'DELETED'", "'DENSE_RANK'", "'DEPENDENTS'", "'DES'", 
		"'DESCRIPTION'", "'DESX'", "'DHCP'", "'DIALOG'", "'DIRECTORY_NAME'", "'DISABLE'", 
		"'DISABLE_BROKER'", "'DISABLED'", null, "'DOCUMENT'", "'DYNAMIC'", "'ELEMENTS'", 
		"'EMERGENCY'", "'EMPTY'", "'ENABLE'", "'ENABLE_BROKER'", "'ENCRYPTED_VALUE'", 
		"'ENCRYPTION'", "'ENDPOINT_URL'", "'ERROR_BROKER_CONVERSATIONS'", "'EXCLUSIVE'", 
		"'EXECUTABLE'", "'EXIST'", "'EXPAND'", "'EXPIRY_DATE'", "'EXPLICIT'", 
		"'FAIL_OPERATION'", "'FAILOVER_MODE'", "'FAILURE'", "'FAILURE_CONDITION_LEVEL'", 
		"'FAST'", "'FAST_FORWARD'", "'FILEGROUP'", "'FILEGROWTH'", "'FILEPATH'", 
		"'FILESTREAM'", "'FILTER'", "'FIRST'", "'FIRST_VALUE'", "'FOLLOWING'", 
		"'FORCE'", "'FORCE_FAILOVER_ALLOW_DATA_LOSS'", "'FORCED'", "'FORMAT'", 
		"'FORWARD_ONLY'", "'FULLSCAN'", "'FULLTEXT'", "'GB'", "'GETDATE'", "'GETUTCDATE'", 
		"'GLOBAL'", "'GO'", "'GROUP_MAX_REQUESTS'", "'GROUPING'", "'GROUPING_ID'", 
		"'HADR'", "'HASH'", "'HEALTH_CHECK_TIMEOUT'", "'HIGH'", "'HONOR_BROKER_PRIORITY'", 
		"'HOURS'", "'IDENTITY_VALUE'", "'IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX'", 
		"'IMMEDIATE'", "'IMPERSONATE'", "'IMPORTANCE'", "'INCLUDE_NULL_VALUES'", 
		"'INCREMENTAL'", "'INITIATOR'", "'INPUT'", "'INSENSITIVE'", "'INSERTED'", 
		"'INT'", "'IP'", "'ISOLATION'", "'JSON'", "'KB'", "'KEEP'", "'KEEPFIXED'", 
		"'KEY_SOURCE'", "'KEYS'", "'KEYSET'", "'LAG'", "'LAST'", "'LAST_VALUE'", 
		"'LEAD'", "'LEVEL'", "'LIST'", "'LISTENER'", "'LISTENER_URL'", "'LOB_COMPACTION'", 
		"'LOCAL'", "'LOCATION'", "'LOCK'", "'LOCK_ESCALATION'", "'LOGIN'", "'LOOP'", 
		"'LOW'", "'MANUAL'", "'MARK'", "'MATERIALIZED'", "'MAX'", "'MAX_CPU_PERCENT'", 
		"'MAX_DOP'", "'MAX_FILES'", "'MAX_IOPS_PER_VOLUME'", "'MAX_MEMORY_PERCENT'", 
		"'MAX_PROCESSES'", "'MAX_QUEUE_READERS'", "'MAX_ROLLOVER_FILES'", "'MAXDOP'", 
		"'MAXRECURSION'", "'MAXSIZE'", "'MB'", "'MEDIUM'", "'MEMORY_OPTIMIZED_DATA'", 
		"'MESSAGE'", "'MIN'", "'MIN_ACTIVE_ROWVERSION'", "'MIN_CPU_PERCENT'", 
		"'MIN_IOPS_PER_VOLUME'", "'MIN_MEMORY_PERCENT'", "'MINUTES'", "'MIRROR_ADDRESS'", 
		"'MIXED_PAGE_ALLOCATION'", "'MODE'", "'MODIFY'", "'MOVE'", "'MULTI_USER'", 
		"'NAME'", "'NESTED_TRIGGERS'", "'NEW_ACCOUNT'", "'NEW_BROKER'", "'NEW_PASSWORD'", 
		"'NEXT'", "'NO'", "'NO_TRUNCATE'", "'NO_WAIT'", "'NOCOUNT'", "'NODES'", 
		"'NOEXPAND'", "'NON_TRANSACTED_ACCESS'", "'NORECOMPUTE'", "'NORECOVERY'", 
		"'NOWAIT'", "'NTILE'", "'NUMANODE'", "'NUMBER'", "'NUMERIC_ROUNDABORT'", 
		"'OBJECT'", "'OFFLINE'", "'OFFSET'", "'OLD_ACCOUNT'", "'ONLINE'", "'ONLY'", 
		"'OPEN_EXISTING'", "'OPTIMISTIC'", "'OPTIMIZE'", "'OUT'", "'OUTPUT'", 
		"'OWNER'", "'PAGE_VERIFY'", "'PARAMETERIZATION'", "'PARTITION'", "'PARTITIONS'", 
		"'PARTNER'", "'PATH'", "'POISON_MESSAGE_HANDLING'", "'POOL'", "'PORT'", 
		"'PRECEDING'", "'PRIMARY_ROLE'", "'PRIOR'", "'PRIORITY'", "'PRIORITY_LEVEL'", 
		"'PRIVATE'", "'PRIVATE_KEY'", "'PRIVILEGES'", "'PROCEDURE_NAME'", "'PROPERTY'", 
		"'PROVIDER'", "'PROVIDER_KEY_NAME'", "'QUERY'", "'QUEUE'", "'QUEUE_DELAY'", 
		"'QUOTED_IDENTIFIER'", "'RANGE'", "'RANK'", "'RC2'", "'RC4'", "'RC4_128'", 
		"'READ_COMMITTED_SNAPSHOT'", "'READ_ONLY'", "'READ_ONLY_ROUTING_LIST'", 
		"'READ_WRITE'", "'READONLY'", "'REBUILD'", "'RECEIVE'", "'RECOMPILE'", 
		"'RECOVERY'", "'RECURSIVE_TRIGGERS'", "'RELATIVE'", "'REMOTE'", "'REMOTE_SERVICE_NAME'", 
		"'REMOVE'", "'REORGANIZE'", "'REPEATABLE'", "'REPLICA'", "'REQUEST_MAX_CPU_TIME_SEC'", 
		"'REQUEST_MAX_MEMORY_GRANT_PERCENT'", "'REQUEST_MEMORY_GRANT_TIMEOUT_SEC'", 
		"'REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT'", "'RESERVE_DISK_SPACE'", 
		"'RESOURCE'", "'RESOURCE_MANAGER_LOCATION'", "'RESTRICTED_USER'", "'RETENTION'", 
		"'ROBUST'", "'ROOT'", "'ROUTE'", "'ROW'", "'ROW_NUMBER'", "'ROWGUID'", 
		"'ROWS'", "'SAMPLE'", "'SCHEMABINDING'", "'SCOPED'", "'SCROLL'", "'SCROLL_LOCKS'", 
		"'SEARCH'", "'SECONDARY'", "'SECONDARY_ONLY'", "'SECONDARY_ROLE'", "'SECONDS'", 
		"'SECRET'", "'SECURITY_LOG'", "'SEEDING_MODE'", "'SELF'", "'SEMI_SENSITIVE'", 
		"'SEND'", "'SENT'", "'SERIALIZABLE'", "'SESSION_TIMEOUT'", "'SETERROR'", 
		"'SHARE'", "'SHOWPLAN'", "'SIGNATURE'", "'SIMPLE'", "'SINGLE_USER'", "'SIZE'", 
		"'SMALLINT'", "'SNAPSHOT'", "'SPATIAL_WINDOW_MAX_CELLS'", "'STANDBY'", 
		"'START_DATE'", "'STATIC'", "'STATS_STREAM'", "'STATUS'", "'STDEV'", "'STDEVP'", 
		"'STOPLIST'", "'STUFF'", "'SUBJECT'", "'SUM'", "'SUSPEND'", "'SYMMETRIC'", 
		"'SYNCHRONOUS_COMMIT'", "'SYNONYM'", "'TAKE'", "'TARGET_RECOVERY_TIME'", 
		"'TB'", "'TEXTIMAGE_ON'", "'THROW'", "'TIES'", "'TIME'", "'TIMEOUT'", 
		"'TIMER'", "'TINYINT'", "'TORN_PAGE_DETECTION'", "'TRANSFORM_NOISE_WORDS'", 
		"'TRIPLE_DES'", "'TRIPLE_DES_3KEY'", "'TRUSTWORTHY'", "'TRY'", "'TSQL'", 
		"'TWO_DIGIT_YEAR_CUTOFF'", "'TYPE'", "'TYPE_WARNING'", "'UNBOUNDED'", 
		"'UNCOMMITTED'", "'UNKNOWN'", "'UNLIMITED'", "'USING'", "'VALID_XML'", 
		"'VALIDATION'", "'VALUE'", "'VAR'", "'VARP'", "'VIEW_METADATA'", "'VIEWS'", 
		"'WAIT'", "'WELL_FORMED_XML'", "'WITHOUT_ARRAY_WRAPPER'", "'WORK'", "'WORKLOAD'", 
		"'XML'", "'XMLDATA'", "'XMLNAMESPACES'", "'XMLSCHEMA'", "'XSINIL'", "'$ACTION'", 
		null, null, null, null, "'''", null, null, null, null, null, null, null, 
		null, null, null, "'='", "'>'", "'<'", "'!'", "'+='", "'-='", "'*='", 
		"'/='", "'%='", "'&='", "'^='", "'|='", "'||'", "'.'", "'_'", "'@'", "'#'", 
		"'$'", "'('", "')'", "','", "';'", "':'", "'*'", "'/'", "'%'", "'+'", 
		"'-'", "'~'", "'|'", "'&'", "'^'"
	};
	private static final String[] _SYMBOLIC_NAMES = {
		null, "ABSENT", "ADD", "AES", "ALL", "ALLOW_CONNECTIONS", "ALLOW_MULTIPLE_EVENT_LOSS", 
		"ALLOW_SINGLE_EVENT_LOSS", "ALTER", "AND", "ANONYMOUS", "ANY", "APPEND", 
		"APPLICATION", "AS", "ASC", "ASYMMETRIC", "ASYNCHRONOUS_COMMIT", "AUTHORIZATION", 
		"AUTHENTICATION", "AUTOMATED_BACKUP_PREFERENCE", "AUTOMATIC", "AVAILABILITY_MODE", 
		"BACKSLASH", "BACKUP", "BEFORE", "BEGIN", "BETWEEN", "BLOCK", "BLOCKSIZE", 
		"BLOCKING_HIERARCHY", "BREAK", "BROWSE", "BUFFER", "BUFFERCOUNT", "BULK", 
		"BY", "CACHE", "CALLED", "CASCADE", "CASE", "CERTIFICATE", "CHANGETABLE", 
		"CHANGES", "CHECK", "CHECKPOINT", "CHECK_POLICY", "CHECK_EXPIRATION", 
		"CLASSIFIER_FUNCTION", "CLOSE", "CLUSTER", "CLUSTERED", "COALESCE", "COLLATE", 
		"COLUMN", "COMPRESSION", "COMMIT", "COMPUTE", "CONFIGURATION", "CONSTRAINT", 
		"CONTAINMENT", "CONTAINS", "CONTAINSTABLE", "CONTEXT", "CONTINUE", "CONTINUE_AFTER_ERROR", 
		"CONTRACT", "CONTRACT_NAME", "CONVERSATION", "CONVERT", "COPY_ONLY", "CREATE", 
		"CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
		"CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATA_COMPRESSION", "DATA_SOURCE", 
		"DATABASE", "DATABASE_MIRRORING", "DBCC", "DEALLOCATE", "DECLARE", "DEFAULT", 
		"DEFAULT_DATABASE", "DEFAULT_SCHEMA", "DELETE", "DENY", "DESC", "DIAGNOSTICS", 
		"DIFFERENTIAL", "DISK", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DOUBLE_BACK_SLASH", 
		"DOUBLE_FORWARD_SLASH", "DROP", "DTC_SUPPORT", "DUMP", "ELSE", "ENABLED", 
		"END", "ENDPOINT", "ERRLVL", "ESCAPE", "ERROR", "EVENT", "EVENTDATA", 
		"EVENT_RETENTION_MODE", "EXCEPT", "EXECUTABLE_FILE", "EXECUTE", "EXISTS", 
		"EXPIREDATE", "EXIT", "EXTENSION", "EXTERNAL", "EXTERNAL_ACCESS", "FAILOVER", 
		"FAILURECONDITIONLEVEL", "FAN_IN", "FETCH", "FILE", "FILENAME", "FILLFACTOR", 
		"FILE_SNAPSHOT", "FOR", "FORCESEEK", "FORCE_SERVICE_ALLOW_DATA_LOSS", 
		"FOREIGN", "FREETEXT", "FREETEXTTABLE", "FROM", "FULL", "FUNCTION", "GET", 
		"GOTO", "GOVERNOR", "GRANT", "GROUP", "HAVING", "HASHED", "HEALTHCHECKTIMEOUT", 
		"IDENTITY", "IDENTITYCOL", "IDENTITY_INSERT", "IF", "IN", "INCLUDE", "INCREMENT", 
		"INDEX", "INFINITE", "INIT", "INNER", "INSERT", "INSTEAD", "INTERSECT", 
		"INTO", "IPV4_ADDR", "IPV6_ADDR", "IS", "ISNULL", "JOIN", "KERBEROS", 
		"KEY", "KEY_PATH", "KEY_STORE_PROVIDER_NAME", "KILL", "LANGUAGE", "LEFT", 
		"LIBRARY", "LIFETIME", "LIKE", "LINENO", "LINUX", "LISTENER_IP", "LISTENER_PORT", 
		"LOAD", "LOCAL_SERVICE_NAME", "LOG", "MATCHED", "MASTER", "MAX_MEMORY", 
		"MAXTRANSFER", "MAXVALUE", "MAX_DISPATCH_LATENCY", "MAX_EVENT_SIZE", "MAX_SIZE", 
		"MAX_OUTSTANDING_IO_PER_VOLUME", "MEDIADESCRIPTION", "MEDIANAME", "MEMBER", 
		"MEMORY_PARTITION_MODE", "MERGE", "MESSAGE_FORWARDING", "MESSAGE_FORWARD_SIZE", 
		"MINVALUE", "MIRROR", "MUST_CHANGE", "NATIONAL", "NEGOTIATE", "NOCHECK", 
		"NOFORMAT", "NOINIT", "NONCLUSTERED", "NONE", "NOREWIND", "NOSKIP", "NOUNLOAD", 
		"NO_CHECKSUM", "NO_COMPRESSION", "NO_EVENT_LOSS", "NOT", "NOTIFICATION", 
		"NTLM", "NULL", "NULLIF", "OF", "OFF", "OFFSETS", "OLD_PASSWORD", "ON", 
		"ON_FAILURE", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", "OPENXML", 
		"OPTION", "OR", "ORDER", "OUTER", "OVER", "PAGE", "PARAM_NODE", "PARTIAL", 
		"PASSWORD", "PERCENT", "PERMISSION_SET", "PER_CPU", "PER_DB", "PER_NODE", 
		"PIVOT", "PLAN", "PLATFORM", "POLICY", "PRECISION", "PREDICATE", "PRIMARY", 
		"PRINT", "PROC", "PROCEDURE", "PROCESS", "PUBLIC", "PYTHON", "R", "RAISERROR", 
		"RAW", "READ", "READTEXT", "READ_WRITE_FILEGROUPS", "RECONFIGURE", "REFERENCES", 
		"REGENERATE", "RELATED_CONVERSATION", "RELATED_CONVERSATION_GROUP", "REPLICATION", 
		"REQUIRED", "RESET", "RESTART", "RESTORE", "RESTRICT", "RESUME", "RETAINDAYS", 
		"RETURN", "RETURNS", "REVERT", "REVOKE", "REWIND", "RIGHT", "ROLLBACK", 
		"ROLE", "ROWCOUNT", "ROWGUIDCOL", "RSA_512", "RSA_1024", "RSA_2048", "RSA_3072", 
		"RSA_4096", "SAFETY", "RULE", "SAFE", "SAVE", "SCHEDULER", "SCHEMA", "SCHEME", 
		"SECURITY", "SECURITYAUDIT", "SELECT", "SEMANTICKEYPHRASETABLE", "SEMANTICSIMILARITYDETAILSTABLE", 
		"SEMANTICSIMILARITYTABLE", "SEQUENCE", "SERVER", "SERVICE", "SERVICE_BROKER", 
		"SERVICE_NAME", "SESSION", "SESSION_USER", "SET", "SETUSER", "SHUTDOWN", 
		"SID", "SKIP_KEYWORD", "SOFTNUMA", "SOME", "SOURCE", "SPECIFICATION", 
		"SPLIT", "SQLDUMPERFLAGS", "SQLDUMPERPATH", "SQLDUMPERTIMEOUT", "STATISTICS", 
		"STATE", "STATS", "START", "STARTED", "STARTUP_STATE", "STOP", "STOPPED", 
		"STOP_ON_ERROR", "SUPPORTED", "SYSTEM", "SYSTEM_USER", "TABLE", "TABLESAMPLE", 
		"TAPE", "TARGET", "TCP", "TEXTSIZE", "THEN", "TO", "TOP", "TRACK_CAUSALITY", 
		"TRAN", "TRANSACTION", "TRANSFER", "TRIGGER", "TRUNCATE", "TSEQUAL", "UNCHECKED", 
		"UNION", "UNIQUE", "UNLOCK", "UNPIVOT", "UNSAFE", "UPDATE", "UPDATETEXT", 
		"URL", "USE", "USED", "USER", "VALUES", "VARYING", "VERBOSELOGGING", "VIEW", 
		"VISIBILITY", "WAITFOR", "WHEN", "WHERE", "WHILE", "WINDOWS", "WITH", 
		"WITHIN", "WITHOUT", "WITNESS", "WRITETEXT", "ABSOLUTE", "ACCENT_SENSITIVITY", 
		"ACTION", "ACTIVATION", "ACTIVE", "ADDRESS", "AES_128", "AES_192", "AES_256", 
		"AFFINITY", "AFTER", "AGGREGATE", "ALGORITHM", "ALLOW_ENCRYPTED_VALUE_MODIFICATIONS", 
		"ALLOW_SNAPSHOT_ISOLATION", "ALLOWED", "ANSI_NULL_DEFAULT", "ANSI_NULLS", 
		"ANSI_PADDING", "ANSI_WARNINGS", "APPLICATION_LOG", "APPLY", "ARITHABORT", 
		"ASSEMBLY", "AUDIT", "AUDIT_GUID", "AUTO", "AUTO_CLEANUP", "AUTO_CLOSE", 
		"AUTO_CREATE_STATISTICS", "AUTO_SHRINK", "AUTO_UPDATE_STATISTICS", "AUTO_UPDATE_STATISTICS_ASYNC", 
		"AVAILABILITY", "AVG", "BACKUP_PRIORITY", "BEGIN_DIALOG", "BIGINT", "BINARY_BASE64", 
		"BINARY_CHECKSUM", "BINDING", "BLOB_STORAGE", "BROKER", "BROKER_INSTANCE", 
		"BULK_LOGGED", "CALLER", "CAP_CPU_PERCENT", "CAST", "CATALOG", "CATCH", 
		"CHANGE_RETENTION", "CHANGE_TRACKING", "CHECKSUM", "CHECKSUM_AGG", "CLEANUP", 
		"COLLECTION", "COLUMN_MASTER_KEY", "COMMITTED", "COMPATIBILITY_LEVEL", 
		"CONCAT", "CONCAT_NULL_YIELDS_NULL", "CONTENT", "CONTROL", "COOKIE", "COUNT", 
		"COUNT_BIG", "COUNTER", "CPU", "CREATE_NEW", "CREATION_DISPOSITION", "CREDENTIAL", 
		"CRYPTOGRAPHIC", "CURSOR_CLOSE_ON_COMMIT", "CURSOR_DEFAULT", "DATE_CORRELATION_OPTIMIZATION", 
		"DATEADD", "DATEDIFF", "DATENAME", "DATEPART", "DAYS", "DB_CHAINING", 
		"DB_FAILOVER", "DECRYPTION", "DEFAULT_DOUBLE_QUOTE", "DEFAULT_FULLTEXT_LANGUAGE", 
		"DEFAULT_LANGUAGE", "DELAY", "DELAYED_DURABILITY", "DELETED", "DENSE_RANK", 
		"DEPENDENTS", "DES", "DESCRIPTION", "DESX", "DHCP", "DIALOG", "DIRECTORY_NAME", 
		"DISABLE", "DISABLE_BROKER", "DISABLED", "DISK_DRIVE", "DOCUMENT", "DYNAMIC", 
		"ELEMENTS", "EMERGENCY", "EMPTY", "ENABLE", "ENABLE_BROKER", "ENCRYPTED_VALUE", 
		"ENCRYPTION", "ENDPOINT_URL", "ERROR_BROKER_CONVERSATIONS", "EXCLUSIVE", 
		"EXECUTABLE", "EXIST", "EXPAND", "EXPIRY_DATE", "EXPLICIT", "FAIL_OPERATION", 
		"FAILOVER_MODE", "FAILURE", "FAILURE_CONDITION_LEVEL", "FAST", "FAST_FORWARD", 
		"FILEGROUP", "FILEGROWTH", "FILEPATH", "FILESTREAM", "FILTER", "FIRST", 
		"FIRST_VALUE", "FOLLOWING", "FORCE", "FORCE_FAILOVER_ALLOW_DATA_LOSS", 
		"FORCED", "FORMAT", "FORWARD_ONLY", "FULLSCAN", "FULLTEXT", "GB", "GETDATE", 
		"GETUTCDATE", "GLOBAL", "GO", "GROUP_MAX_REQUESTS", "GROUPING", "GROUPING_ID", 
		"HADR", "HASH", "HEALTH_CHECK_TIMEOUT", "HIGH", "HONOR_BROKER_PRIORITY", 
		"HOURS", "IDENTITY_VALUE", "IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX", "IMMEDIATE", 
		"IMPERSONATE", "IMPORTANCE", "INCLUDE_NULL_VALUES", "INCREMENTAL", "INITIATOR", 
		"INPUT", "INSENSITIVE", "INSERTED", "INT", "IP", "ISOLATION", "JSON", 
		"KB", "KEEP", "KEEPFIXED", "KEY_SOURCE", "KEYS", "KEYSET", "LAG", "LAST", 
		"LAST_VALUE", "LEAD", "LEVEL", "LIST", "LISTENER", "LISTENER_URL", "LOB_COMPACTION", 
		"LOCAL", "LOCATION", "LOCK", "LOCK_ESCALATION", "LOGIN", "LOOP", "LOW", 
		"MANUAL", "MARK", "MATERIALIZED", "MAX", "MAX_CPU_PERCENT", "MAX_DOP", 
		"MAX_FILES", "MAX_IOPS_PER_VOLUME", "MAX_MEMORY_PERCENT", "MAX_PROCESSES", 
		"MAX_QUEUE_READERS", "MAX_ROLLOVER_FILES", "MAXDOP", "MAXRECURSION", "MAXSIZE", 
		"MB", "MEDIUM", "MEMORY_OPTIMIZED_DATA", "MESSAGE", "MIN", "MIN_ACTIVE_ROWVERSION", 
		"MIN_CPU_PERCENT", "MIN_IOPS_PER_VOLUME", "MIN_MEMORY_PERCENT", "MINUTES", 
		"MIRROR_ADDRESS", "MIXED_PAGE_ALLOCATION", "MODE", "MODIFY", "MOVE", "MULTI_USER", 
		"NAME", "NESTED_TRIGGERS", "NEW_ACCOUNT", "NEW_BROKER", "NEW_PASSWORD", 
		"NEXT", "NO", "NO_TRUNCATE", "NO_WAIT", "NOCOUNT", "NODES", "NOEXPAND", 
		"NON_TRANSACTED_ACCESS", "NORECOMPUTE", "NORECOVERY", "NOWAIT", "NTILE", 
		"NUMANODE", "NUMBER", "NUMERIC_ROUNDABORT", "OBJECT", "OFFLINE", "OFFSET", 
		"OLD_ACCOUNT", "ONLINE", "ONLY", "OPEN_EXISTING", "OPTIMISTIC", "OPTIMIZE", 
		"OUT", "OUTPUT", "OWNER", "PAGE_VERIFY", "PARAMETERIZATION", "PARTITION", 
		"PARTITIONS", "PARTNER", "PATH", "POISON_MESSAGE_HANDLING", "POOL", "PORT", 
		"PRECEDING", "PRIMARY_ROLE", "PRIOR", "PRIORITY", "PRIORITY_LEVEL", "PRIVATE", 
		"PRIVATE_KEY", "PRIVILEGES", "PROCEDURE_NAME", "PROPERTY", "PROVIDER", 
		"PROVIDER_KEY_NAME", "QUERY", "QUEUE", "QUEUE_DELAY", "QUOTED_IDENTIFIER", 
		"RANGE", "RANK", "RC2", "RC4", "RC4_128", "READ_COMMITTED_SNAPSHOT", "READ_ONLY", 
		"READ_ONLY_ROUTING_LIST", "READ_WRITE", "READONLY", "REBUILD", "RECEIVE", 
		"RECOMPILE", "RECOVERY", "RECURSIVE_TRIGGERS", "RELATIVE", "REMOTE", "REMOTE_SERVICE_NAME", 
		"REMOVE", "REORGANIZE", "REPEATABLE", "REPLICA", "REQUEST_MAX_CPU_TIME_SEC", 
		"REQUEST_MAX_MEMORY_GRANT_PERCENT", "REQUEST_MEMORY_GRANT_TIMEOUT_SEC", 
		"REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT", "RESERVE_DISK_SPACE", "RESOURCE", 
		"RESOURCE_MANAGER_LOCATION", "RESTRICTED_USER", "RETENTION", "ROBUST", 
		"ROOT", "ROUTE", "ROW", "ROW_NUMBER", "ROWGUID", "ROWS", "SAMPLE", "SCHEMABINDING", 
		"SCOPED", "SCROLL", "SCROLL_LOCKS", "SEARCH", "SECONDARY", "SECONDARY_ONLY", 
		"SECONDARY_ROLE", "SECONDS", "SECRET", "SECURITY_LOG", "SEEDING_MODE", 
		"SELF", "SEMI_SENSITIVE", "SEND", "SENT", "SERIALIZABLE", "SESSION_TIMEOUT", 
		"SETERROR", "SHARE", "SHOWPLAN", "SIGNATURE", "SIMPLE", "SINGLE_USER", 
		"SIZE", "SMALLINT", "SNAPSHOT", "SPATIAL_WINDOW_MAX_CELLS", "STANDBY", 
		"START_DATE", "STATIC", "STATS_STREAM", "STATUS", "STDEV", "STDEVP", "STOPLIST", 
		"STUFF", "SUBJECT", "SUM", "SUSPEND", "SYMMETRIC", "SYNCHRONOUS_COMMIT", 
		"SYNONYM", "TAKE", "TARGET_RECOVERY_TIME", "TB", "TEXTIMAGE_ON", "THROW", 
		"TIES", "TIME", "TIMEOUT", "TIMER", "TINYINT", "TORN_PAGE_DETECTION", 
		"TRANSFORM_NOISE_WORDS", "TRIPLE_DES", "TRIPLE_DES_3KEY", "TRUSTWORTHY", 
		"TRY", "TSQL", "TWO_DIGIT_YEAR_CUTOFF", "TYPE", "TYPE_WARNING", "UNBOUNDED", 
		"UNCOMMITTED", "UNKNOWN", "UNLIMITED", "USING", "VALID_XML", "VALIDATION", 
		"VALUE", "VAR", "VARP", "VIEW_METADATA", "VIEWS", "WAIT", "WELL_FORMED_XML", 
		"WITHOUT_ARRAY_WRAPPER", "WORK", "WORKLOAD", "XML", "XMLDATA", "XMLNAMESPACES", 
		"XMLSCHEMA", "XSINIL", "DOLLAR_ACTION", "SPACE", "COMMENT", "LINE_COMMENT", 
		"DOUBLE_QUOTE_ID", "SINGLE_QUOTE", "SQUARE_BRACKET_ID", "LOCAL_ID", "DECIMAL", 
		"ID", "QUOTED_URL", "QUOTED_HOST_AND_PORT", "STRING", "BINARY", "FLOAT", 
		"REAL", "EQUAL", "GREATER", "LESS", "EXCLAMATION", "PLUS_ASSIGN", "MINUS_ASSIGN", 
		"MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", 
		"OR_ASSIGN", "DOUBLE_BAR", "DOT", "UNDERLINE", "AT", "SHARP", "DOLLAR", 
		"LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "COLON", "STAR", "DIVIDE", 
		"MODULE", "PLUS", "MINUS", "BIT_NOT", "BIT_OR", "BIT_AND", "BIT_XOR", 
		"IPV4_OCTECT"
	};
	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	@Deprecated
	public static final String[] tokenNames;
	static {
		tokenNames = new String[_SYMBOLIC_NAMES.length];
		for (int i = 0; i < tokenNames.length; i++) {
			tokenNames[i] = VOCABULARY.getLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = VOCABULARY.getSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}
	}

	@Override
	@Deprecated
	public String[] getTokenNames() {
		return tokenNames;
	}

	@Override

	public Vocabulary getVocabulary() {
		return VOCABULARY;
	}

	@Override
	public String getGrammarFileName() { return "SelectParts.g4"; }

	@Override
	public String[] getRuleNames() { return ruleNames; }

	@Override
	public String getSerializedATN() { return _serializedATN; }

	@Override
	public ATN getATN() { return _ATN; }

	public SelectParts(TokenStream input) {
		super(input);
		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
	}
	public static class Select_listContext extends ParserRuleContext {
		public List<Select_list_elemContext> select_list_elem() {
			return getRuleContexts(Select_list_elemContext.class);
		}
		public Select_list_elemContext select_list_elem(int i) {
			return getRuleContext(Select_list_elemContext.class,i);
		}
		public Select_listContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_select_list; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterSelect_list(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitSelect_list(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitSelect_list(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Select_listContext select_list() throws RecognitionException {
		Select_listContext _localctx = new Select_listContext(_ctx, getState());
		enterRule(_localctx, 0, RULE_select_list);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(54);
			select_list_elem();
			setState(59);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==COMMA) {
				{
				{
				setState(55);
				match(COMMA);
				setState(56);
				select_list_elem();
				}
				}
				setState(61);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Select_list_elemContext extends ParserRuleContext {
		public AsteriskContext asterisk() {
			return getRuleContext(AsteriskContext.class,0);
		}
		public Column_elemContext column_elem() {
			return getRuleContext(Column_elemContext.class,0);
		}
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public As_column_aliasContext as_column_alias() {
			return getRuleContext(As_column_aliasContext.class,0);
		}
		public Select_list_elemContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_select_list_elem; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterSelect_list_elem(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitSelect_list_elem(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitSelect_list_elem(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Select_list_elemContext select_list_elem() throws RecognitionException {
		Select_list_elemContext _localctx = new Select_list_elemContext(_ctx, getState());
		enterRule(_localctx, 2, RULE_select_list_elem);
		int _la;
		try {
			setState(68);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,2,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(62);
				asterisk();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(63);
				column_elem();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(64);
				expression(0);
				setState(66);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==AS || _la==INIT || _la==ROWCOUNT || ((((_la - 394)) & ~0x3f) == 0 && ((1L << (_la - 394)) & ((1L << (AGGREGATE - 394)) | (1L << (AVG - 394)) | (1L << (BIGINT - 394)) | (1L << (BINARY_BASE64 - 394)) | (1L << (COUNT - 394)) | (1L << (COUNT_BIG - 394)) | (1L << (COUNTER - 394)))) != 0) || ((((_la - 458)) & ~0x3f) == 0 && ((1L << (_la - 458)) & ((1L << (DATEADD - 458)) | (1L << (DATEDIFF - 458)) | (1L << (DATENAME - 458)) | (1L << (DATEPART - 458)) | (1L << (DAYS - 458)) | (1L << (FIRST - 458)) | (1L << (FIRST_VALUE - 458)) | (1L << (FOLLOWING - 458)))) != 0) || ((((_la - 535)) & ~0x3f) == 0 && ((1L << (_la - 535)) & ((1L << (HOURS - 535)) | (1L << (IDENTITY_VALUE - 535)) | (1L << (INT - 535)) | (1L << (LAST - 535)) | (1L << (LAST_VALUE - 535)) | (1L << (LOW - 535)) | (1L << (MAX - 535)) | (1L << (MIN - 535)) | (1L << (MINUTES - 535)))) != 0) || _la==NUMBER || ((((_la - 695)) & ~0x3f) == 0 && ((1L << (_la - 695)) & ((1L << (ROW - 695)) | (1L << (ROW_NUMBER - 695)) | (1L << (SUM - 695)) | (1L << (TIME - 695)))) != 0) || _la==ID || _la==STRING) {
					{
					setState(65);
					as_column_alias();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class As_column_aliasContext extends ParserRuleContext {
		public Column_aliasContext column_alias() {
			return getRuleContext(Column_aliasContext.class,0);
		}
		public TerminalNode AS() { return getToken(SelectParts.AS, 0); }
		public As_column_aliasContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_as_column_alias; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterAs_column_alias(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitAs_column_alias(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitAs_column_alias(this);
			else return visitor.visitChildren(this);
		}
	}

	public final As_column_aliasContext as_column_alias() throws RecognitionException {
		As_column_aliasContext _localctx = new As_column_aliasContext(_ctx, getState());
		enterRule(_localctx, 4, RULE_as_column_alias);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(71);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==AS) {
				{
				setState(70);
				match(AS);
				}
			}

			setState(73);
			column_alias();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Column_aliasContext extends ParserRuleContext {
		public IdContext id() {
			return getRuleContext(IdContext.class,0);
		}
		public TerminalNode STRING() { return getToken(SelectParts.STRING, 0); }
		public Column_aliasContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_column_alias; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterColumn_alias(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitColumn_alias(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitColumn_alias(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Column_aliasContext column_alias() throws RecognitionException {
		Column_aliasContext _localctx = new Column_aliasContext(_ctx, getState());
		enterRule(_localctx, 6, RULE_column_alias);
		try {
			setState(77);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case INIT:
			case ROWCOUNT:
			case AGGREGATE:
			case AVG:
			case BIGINT:
			case BINARY_BASE64:
			case COUNT:
			case COUNT_BIG:
			case COUNTER:
			case DATEADD:
			case DATEDIFF:
			case DATENAME:
			case DATEPART:
			case DAYS:
			case FIRST:
			case FIRST_VALUE:
			case FOLLOWING:
			case HOURS:
			case IDENTITY_VALUE:
			case INT:
			case LAST:
			case LAST_VALUE:
			case LOW:
			case MAX:
			case MIN:
			case MINUTES:
			case NUMBER:
			case ROW:
			case ROW_NUMBER:
			case SUM:
			case TIME:
			case ID:
				enterOuterAlt(_localctx, 1);
				{
				setState(75);
				id();
				}
				break;
			case STRING:
				enterOuterAlt(_localctx, 2);
				{
				setState(76);
				match(STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Column_elemContext extends ParserRuleContext {
		public IdContext column_name;
		public Table_nameContext table_name() {
			return getRuleContext(Table_nameContext.class,0);
		}
		public IdContext id() {
			return getRuleContext(IdContext.class,0);
		}
		public As_column_aliasContext as_column_alias() {
			return getRuleContext(As_column_aliasContext.class,0);
		}
		public Column_elemContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_column_elem; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterColumn_elem(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitColumn_elem(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitColumn_elem(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Column_elemContext column_elem() throws RecognitionException {
		Column_elemContext _localctx = new Column_elemContext(_ctx, getState());
		enterRule(_localctx, 8, RULE_column_elem);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(82);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,5,_ctx) ) {
			case 1:
				{
				setState(79);
				table_name();
				setState(80);
				match(DOT);
				}
				break;
			}
			{
			setState(84);
			((Column_elemContext)_localctx).column_name = id();
			}
			setState(86);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==AS || _la==INIT || _la==ROWCOUNT || ((((_la - 394)) & ~0x3f) == 0 && ((1L << (_la - 394)) & ((1L << (AGGREGATE - 394)) | (1L << (AVG - 394)) | (1L << (BIGINT - 394)) | (1L << (BINARY_BASE64 - 394)) | (1L << (COUNT - 394)) | (1L << (COUNT_BIG - 394)) | (1L << (COUNTER - 394)))) != 0) || ((((_la - 458)) & ~0x3f) == 0 && ((1L << (_la - 458)) & ((1L << (DATEADD - 458)) | (1L << (DATEDIFF - 458)) | (1L << (DATENAME - 458)) | (1L << (DATEPART - 458)) | (1L << (DAYS - 458)) | (1L << (FIRST - 458)) | (1L << (FIRST_VALUE - 458)) | (1L << (FOLLOWING - 458)))) != 0) || ((((_la - 535)) & ~0x3f) == 0 && ((1L << (_la - 535)) & ((1L << (HOURS - 535)) | (1L << (IDENTITY_VALUE - 535)) | (1L << (INT - 535)) | (1L << (LAST - 535)) | (1L << (LAST_VALUE - 535)) | (1L << (LOW - 535)) | (1L << (MAX - 535)) | (1L << (MIN - 535)) | (1L << (MINUTES - 535)))) != 0) || _la==NUMBER || ((((_la - 695)) & ~0x3f) == 0 && ((1L << (_la - 695)) & ((1L << (ROW - 695)) | (1L << (ROW_NUMBER - 695)) | (1L << (SUM - 695)) | (1L << (TIME - 695)))) != 0) || _la==ID || _la==STRING) {
				{
				setState(85);
				as_column_alias();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class AsteriskContext extends ParserRuleContext {
		public Table_nameContext table_name() {
			return getRuleContext(Table_nameContext.class,0);
		}
		public AsteriskContext asterisk() {
			return getRuleContext(AsteriskContext.class,0);
		}
		public AsteriskContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_asterisk; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterAsterisk(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitAsterisk(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitAsterisk(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AsteriskContext asterisk() throws RecognitionException {
		AsteriskContext _localctx = new AsteriskContext(_ctx, getState());
		enterRule(_localctx, 10, RULE_asterisk);
		try {
			setState(93);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case STAR:
				enterOuterAlt(_localctx, 1);
				{
				setState(88);
				match(STAR);
				}
				break;
			case BLOCKING_HIERARCHY:
			case INIT:
			case ROWCOUNT:
			case AGGREGATE:
			case AVG:
			case BIGINT:
			case BINARY_BASE64:
			case COUNT:
			case COUNT_BIG:
			case COUNTER:
			case DATEADD:
			case DATEDIFF:
			case DATENAME:
			case DATEPART:
			case DAYS:
			case FIRST:
			case FIRST_VALUE:
			case FOLLOWING:
			case HOURS:
			case IDENTITY_VALUE:
			case INT:
			case LAST:
			case LAST_VALUE:
			case LOW:
			case MAX:
			case MIN:
			case MINUTES:
			case NUMBER:
			case ROW:
			case ROW_NUMBER:
			case SUM:
			case TIME:
			case ID:
				enterOuterAlt(_localctx, 2);
				{
				setState(89);
				table_name();
				setState(90);
				match(DOT);
				setState(91);
				asterisk();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Search_conditionContext extends ParserRuleContext {
		public List<Search_condition_andContext> search_condition_and() {
			return getRuleContexts(Search_condition_andContext.class);
		}
		public Search_condition_andContext search_condition_and(int i) {
			return getRuleContext(Search_condition_andContext.class,i);
		}
		public List<TerminalNode> OR() { return getTokens(SelectParts.OR); }
		public TerminalNode OR(int i) {
			return getToken(SelectParts.OR, i);
		}
		public Search_conditionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_search_condition; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterSearch_condition(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitSearch_condition(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitSearch_condition(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Search_conditionContext search_condition() throws RecognitionException {
		Search_conditionContext _localctx = new Search_conditionContext(_ctx, getState());
		enterRule(_localctx, 12, RULE_search_condition);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(95);
			search_condition_and();
			setState(100);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==OR) {
				{
				{
				setState(96);
				match(OR);
				setState(97);
				search_condition_and();
				}
				}
				setState(102);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Search_condition_andContext extends ParserRuleContext {
		public List<Search_condition_notContext> search_condition_not() {
			return getRuleContexts(Search_condition_notContext.class);
		}
		public Search_condition_notContext search_condition_not(int i) {
			return getRuleContext(Search_condition_notContext.class,i);
		}
		public List<TerminalNode> AND() { return getTokens(SelectParts.AND); }
		public TerminalNode AND(int i) {
			return getToken(SelectParts.AND, i);
		}
		public Search_condition_andContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_search_condition_and; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterSearch_condition_and(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitSearch_condition_and(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitSearch_condition_and(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Search_condition_andContext search_condition_and() throws RecognitionException {
		Search_condition_andContext _localctx = new Search_condition_andContext(_ctx, getState());
		enterRule(_localctx, 14, RULE_search_condition_and);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(103);
			search_condition_not();
			setState(108);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==AND) {
				{
				{
				setState(104);
				match(AND);
				setState(105);
				search_condition_not();
				}
				}
				setState(110);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Search_condition_notContext extends ParserRuleContext {
		public PredicateContext predicate() {
			return getRuleContext(PredicateContext.class,0);
		}
		public TerminalNode NOT() { return getToken(SelectParts.NOT, 0); }
		public Search_condition_notContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_search_condition_not; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterSearch_condition_not(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitSearch_condition_not(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitSearch_condition_not(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Search_condition_notContext search_condition_not() throws RecognitionException {
		Search_condition_notContext _localctx = new Search_condition_notContext(_ctx, getState());
		enterRule(_localctx, 16, RULE_search_condition_not);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(112);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==NOT) {
				{
				setState(111);
				match(NOT);
				}
			}

			setState(114);
			predicate();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class PredicateContext extends ParserRuleContext {
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public Comparison_operatorContext comparison_operator() {
			return getRuleContext(Comparison_operatorContext.class,0);
		}
		public TerminalNode IN() { return getToken(SelectParts.IN, 0); }
		public Expression_listContext expression_list() {
			return getRuleContext(Expression_listContext.class,0);
		}
		public TerminalNode NOT() { return getToken(SelectParts.NOT, 0); }
		public TerminalNode LIKE() { return getToken(SelectParts.LIKE, 0); }
		public TerminalNode IS() { return getToken(SelectParts.IS, 0); }
		public Null_notnullContext null_notnull() {
			return getRuleContext(Null_notnullContext.class,0);
		}
		public Search_conditionContext search_condition() {
			return getRuleContext(Search_conditionContext.class,0);
		}
		public PredicateContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_predicate; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterPredicate(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitPredicate(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitPredicate(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PredicateContext predicate() throws RecognitionException {
		PredicateContext _localctx = new PredicateContext(_ctx, getState());
		enterRule(_localctx, 18, RULE_predicate);
		int _la;
		try {
			setState(144);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,13,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(116);
				expression(0);
				setState(117);
				comparison_operator();
				setState(118);
				expression(0);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(120);
				expression(0);
				setState(122);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==NOT) {
					{
					setState(121);
					match(NOT);
					}
				}

				setState(124);
				match(IN);
				setState(125);
				match(LR_BRACKET);
				setState(126);
				expression_list();
				setState(127);
				match(RR_BRACKET);
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(129);
				expression(0);
				setState(131);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==NOT) {
					{
					setState(130);
					match(NOT);
					}
				}

				setState(133);
				match(LIKE);
				setState(134);
				expression(0);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(136);
				expression(0);
				setState(137);
				match(IS);
				setState(138);
				null_notnull();
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(140);
				match(LR_BRACKET);
				setState(141);
				search_condition();
				setState(142);
				match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Expression_listContext extends ParserRuleContext {
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public Expression_listContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expression_list; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterExpression_list(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitExpression_list(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitExpression_list(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Expression_listContext expression_list() throws RecognitionException {
		Expression_listContext _localctx = new Expression_listContext(_ctx, getState());
		enterRule(_localctx, 20, RULE_expression_list);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(146);
			expression(0);
			setState(151);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==COMMA) {
				{
				{
				setState(147);
				match(COMMA);
				setState(148);
				expression(0);
				}
				}
				setState(153);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ExpressionContext extends ParserRuleContext {
		public Token op;
		public Primitive_expressionContext primitive_expression() {
			return getRuleContext(Primitive_expressionContext.class,0);
		}
		public Function_callContext function_call() {
			return getRuleContext(Function_callContext.class,0);
		}
		public Full_column_nameContext full_column_name() {
			return getRuleContext(Full_column_nameContext.class,0);
		}
		public Bracket_expressionContext bracket_expression() {
			return getRuleContext(Bracket_expressionContext.class,0);
		}
		public Unary_operator_expressionContext unary_operator_expression() {
			return getRuleContext(Unary_operator_expressionContext.class,0);
		}
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public Comparison_operatorContext comparison_operator() {
			return getRuleContext(Comparison_operatorContext.class,0);
		}
		public Assignment_operatorContext assignment_operator() {
			return getRuleContext(Assignment_operatorContext.class,0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExpressionContext expression() throws RecognitionException {
		return expression(0);
	}

	private ExpressionContext expression(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 22;
		enterRecursionRule(_localctx, 22, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(160);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,15,_ctx) ) {
			case 1:
				{
				setState(155);
				primitive_expression();
				}
				break;
			case 2:
				{
				setState(156);
				function_call();
				}
				break;
			case 3:
				{
				setState(157);
				full_column_name();
				}
				break;
			case 4:
				{
				setState(158);
				bracket_expression();
				}
				break;
			case 5:
				{
				setState(159);
				unary_operator_expression();
				}
				break;
			}
			_ctx.stop = _input.LT(-1);
			setState(178);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,17,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					setState(176);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,16,_ctx) ) {
					case 1:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_expression);
						setState(162);
						if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, "precpred(_ctx, 4)");
						setState(163);
						((ExpressionContext)_localctx).op = _input.LT(1);
						_la = _input.LA(1);
						if ( !(((((_la - 824)) & ~0x3f) == 0 && ((1L << (_la - 824)) & ((1L << (STAR - 824)) | (1L << (DIVIDE - 824)) | (1L << (MODULE - 824)))) != 0)) ) {
							((ExpressionContext)_localctx).op = (Token)_errHandler.recoverInline(this);
						}
						else {
							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
							_errHandler.reportMatch(this);
							consume();
						}
						setState(164);
						expression(5);
						}
						break;
					case 2:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_expression);
						setState(165);
						if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, "precpred(_ctx, 3)");
						setState(166);
						((ExpressionContext)_localctx).op = _input.LT(1);
						_la = _input.LA(1);
						if ( !(((((_la - 813)) & ~0x3f) == 0 && ((1L << (_la - 813)) & ((1L << (DOUBLE_BAR - 813)) | (1L << (PLUS - 813)) | (1L << (MINUS - 813)) | (1L << (BIT_OR - 813)) | (1L << (BIT_AND - 813)) | (1L << (BIT_XOR - 813)))) != 0)) ) {
							((ExpressionContext)_localctx).op = (Token)_errHandler.recoverInline(this);
						}
						else {
							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
							_errHandler.reportMatch(this);
							consume();
						}
						setState(167);
						expression(4);
						}
						break;
					case 3:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_expression);
						setState(168);
						if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, "precpred(_ctx, 2)");
						setState(169);
						comparison_operator();
						setState(170);
						expression(3);
						}
						break;
					case 4:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_expression);
						setState(172);
						if (!(precpred(_ctx, 1))) throw new FailedPredicateException(this, "precpred(_ctx, 1)");
						setState(173);
						assignment_operator();
						setState(174);
						expression(2);
						}
						break;
					}
					} 
				}
				setState(180);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,17,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public static class Function_callContext extends ParserRuleContext {
		public Aggregate_windowed_functionContext aggregate_windowed_function() {
			return getRuleContext(Aggregate_windowed_functionContext.class,0);
		}
		public Func_proc_nameContext func_proc_name() {
			return getRuleContext(Func_proc_nameContext.class,0);
		}
		public Expression_listContext expression_list() {
			return getRuleContext(Expression_listContext.class,0);
		}
		public Function_callContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_function_call; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterFunction_call(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitFunction_call(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitFunction_call(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Function_callContext function_call() throws RecognitionException {
		Function_callContext _localctx = new Function_callContext(_ctx, getState());
		enterRule(_localctx, 24, RULE_function_call);
		int _la;
		try {
			setState(189);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,19,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(181);
				aggregate_windowed_function();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(182);
				func_proc_name();
				setState(183);
				match(LR_BRACKET);
				setState(185);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==BLOCKING_HIERARCHY || _la==DEFAULT || _la==INIT || _la==NULL || _la==ROWCOUNT || ((((_la - 394)) & ~0x3f) == 0 && ((1L << (_la - 394)) & ((1L << (AGGREGATE - 394)) | (1L << (AVG - 394)) | (1L << (BIGINT - 394)) | (1L << (BINARY_BASE64 - 394)) | (1L << (COUNT - 394)) | (1L << (COUNT_BIG - 394)) | (1L << (COUNTER - 394)))) != 0) || ((((_la - 458)) & ~0x3f) == 0 && ((1L << (_la - 458)) & ((1L << (DATEADD - 458)) | (1L << (DATEDIFF - 458)) | (1L << (DATENAME - 458)) | (1L << (DATEPART - 458)) | (1L << (DAYS - 458)) | (1L << (FIRST - 458)) | (1L << (FIRST_VALUE - 458)) | (1L << (FOLLOWING - 458)))) != 0) || ((((_la - 535)) & ~0x3f) == 0 && ((1L << (_la - 535)) & ((1L << (HOURS - 535)) | (1L << (IDENTITY_VALUE - 535)) | (1L << (INT - 535)) | (1L << (LAST - 535)) | (1L << (LAST_VALUE - 535)) | (1L << (LOW - 535)) | (1L << (MAX - 535)) | (1L << (MIN - 535)) | (1L << (MINUTES - 535)))) != 0) || _la==NUMBER || ((((_la - 695)) & ~0x3f) == 0 && ((1L << (_la - 695)) & ((1L << (ROW - 695)) | (1L << (ROW_NUMBER - 695)) | (1L << (STDEV - 695)) | (1L << (STDEVP - 695)) | (1L << (SUM - 695)) | (1L << (TIME - 695)))) != 0) || ((((_la - 771)) & ~0x3f) == 0 && ((1L << (_la - 771)) & ((1L << (VAR - 771)) | (1L << (VARP - 771)) | (1L << (LOCAL_ID - 771)) | (1L << (DECIMAL - 771)) | (1L << (ID - 771)) | (1L << (STRING - 771)) | (1L << (BINARY - 771)) | (1L << (FLOAT - 771)) | (1L << (REAL - 771)) | (1L << (LR_BRACKET - 771)) | (1L << (PLUS - 771)) | (1L << (MINUS - 771)) | (1L << (BIT_NOT - 771)))) != 0)) {
					{
					setState(184);
					expression_list();
					}
				}

				setState(187);
				match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Aggregate_windowed_functionContext extends ParserRuleContext {
		public Full_column_nameContext full_column_name() {
			return getRuleContext(Full_column_nameContext.class,0);
		}
		public TerminalNode AVG() { return getToken(SelectParts.AVG, 0); }
		public TerminalNode MAX() { return getToken(SelectParts.MAX, 0); }
		public TerminalNode MIN() { return getToken(SelectParts.MIN, 0); }
		public TerminalNode SUM() { return getToken(SelectParts.SUM, 0); }
		public TerminalNode STDEV() { return getToken(SelectParts.STDEV, 0); }
		public TerminalNode STDEVP() { return getToken(SelectParts.STDEVP, 0); }
		public TerminalNode VAR() { return getToken(SelectParts.VAR, 0); }
		public TerminalNode VARP() { return getToken(SelectParts.VARP, 0); }
		public TerminalNode COUNT() { return getToken(SelectParts.COUNT, 0); }
		public TerminalNode COUNT_BIG() { return getToken(SelectParts.COUNT_BIG, 0); }
		public Aggregate_windowed_functionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_aggregate_windowed_function; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterAggregate_windowed_function(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitAggregate_windowed_function(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitAggregate_windowed_function(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Aggregate_windowed_functionContext aggregate_windowed_function() throws RecognitionException {
		Aggregate_windowed_functionContext _localctx = new Aggregate_windowed_functionContext(_ctx, getState());
		enterRule(_localctx, 26, RULE_aggregate_windowed_function);
		int _la;
		try {
			setState(203);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case AVG:
			case MAX:
			case MIN:
			case STDEV:
			case STDEVP:
			case SUM:
			case VAR:
			case VARP:
				enterOuterAlt(_localctx, 1);
				{
				setState(191);
				_la = _input.LA(1);
				if ( !(_la==AVG || _la==MAX || _la==MIN || ((((_la - 733)) & ~0x3f) == 0 && ((1L << (_la - 733)) & ((1L << (STDEV - 733)) | (1L << (STDEVP - 733)) | (1L << (SUM - 733)) | (1L << (VAR - 733)) | (1L << (VARP - 733)))) != 0)) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(192);
				match(LR_BRACKET);
				setState(193);
				full_column_name();
				setState(194);
				match(RR_BRACKET);
				}
				break;
			case COUNT:
			case COUNT_BIG:
				enterOuterAlt(_localctx, 2);
				{
				setState(196);
				_la = _input.LA(1);
				if ( !(_la==COUNT || _la==COUNT_BIG) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(197);
				match(LR_BRACKET);
				setState(200);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case STAR:
					{
					setState(198);
					match(STAR);
					}
					break;
				case BLOCKING_HIERARCHY:
				case INIT:
				case ROWCOUNT:
				case AGGREGATE:
				case AVG:
				case BIGINT:
				case BINARY_BASE64:
				case COUNT:
				case COUNT_BIG:
				case COUNTER:
				case DATEADD:
				case DATEDIFF:
				case DATENAME:
				case DATEPART:
				case DAYS:
				case FIRST:
				case FIRST_VALUE:
				case FOLLOWING:
				case HOURS:
				case IDENTITY_VALUE:
				case INT:
				case LAST:
				case LAST_VALUE:
				case LOW:
				case MAX:
				case MIN:
				case MINUTES:
				case NUMBER:
				case ROW:
				case ROW_NUMBER:
				case SUM:
				case TIME:
				case ID:
					{
					setState(199);
					full_column_name();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(202);
				match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Func_proc_nameContext extends ParserRuleContext {
		public IdContext procedure;
		public IdContext id() {
			return getRuleContext(IdContext.class,0);
		}
		public Func_proc_nameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_func_proc_name; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterFunc_proc_name(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitFunc_proc_name(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitFunc_proc_name(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Func_proc_nameContext func_proc_name() throws RecognitionException {
		Func_proc_nameContext _localctx = new Func_proc_nameContext(_ctx, getState());
		enterRule(_localctx, 28, RULE_func_proc_name);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(205);
			((Func_proc_nameContext)_localctx).procedure = id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Full_column_nameContext extends ParserRuleContext {
		public IdContext column_name;
		public IdContext id() {
			return getRuleContext(IdContext.class,0);
		}
		public Table_nameContext table_name() {
			return getRuleContext(Table_nameContext.class,0);
		}
		public Full_column_nameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_full_column_name; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterFull_column_name(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitFull_column_name(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitFull_column_name(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Full_column_nameContext full_column_name() throws RecognitionException {
		Full_column_nameContext _localctx = new Full_column_nameContext(_ctx, getState());
		enterRule(_localctx, 30, RULE_full_column_name);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(210);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,22,_ctx) ) {
			case 1:
				{
				setState(207);
				table_name();
				setState(208);
				match(DOT);
				}
				break;
			}
			setState(212);
			((Full_column_nameContext)_localctx).column_name = id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Table_nameContext extends ParserRuleContext {
		public IdContext database;
		public IdContext schema;
		public IdContext table;
		public List<IdContext> id() {
			return getRuleContexts(IdContext.class);
		}
		public IdContext id(int i) {
			return getRuleContext(IdContext.class,i);
		}
		public TerminalNode BLOCKING_HIERARCHY() { return getToken(SelectParts.BLOCKING_HIERARCHY, 0); }
		public Table_nameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_table_name; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterTable_name(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitTable_name(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitTable_name(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Table_nameContext table_name() throws RecognitionException {
		Table_nameContext _localctx = new Table_nameContext(_ctx, getState());
		enterRule(_localctx, 32, RULE_table_name);
		int _la;
		try {
			setState(240);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,27,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(224);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,24,_ctx) ) {
				case 1:
					{
					setState(214);
					((Table_nameContext)_localctx).database = id();
					setState(215);
					match(DOT);
					setState(217);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==INIT || _la==ROWCOUNT || ((((_la - 394)) & ~0x3f) == 0 && ((1L << (_la - 394)) & ((1L << (AGGREGATE - 394)) | (1L << (AVG - 394)) | (1L << (BIGINT - 394)) | (1L << (BINARY_BASE64 - 394)) | (1L << (COUNT - 394)) | (1L << (COUNT_BIG - 394)) | (1L << (COUNTER - 394)))) != 0) || ((((_la - 458)) & ~0x3f) == 0 && ((1L << (_la - 458)) & ((1L << (DATEADD - 458)) | (1L << (DATEDIFF - 458)) | (1L << (DATENAME - 458)) | (1L << (DATEPART - 458)) | (1L << (DAYS - 458)) | (1L << (FIRST - 458)) | (1L << (FIRST_VALUE - 458)) | (1L << (FOLLOWING - 458)))) != 0) || ((((_la - 535)) & ~0x3f) == 0 && ((1L << (_la - 535)) & ((1L << (HOURS - 535)) | (1L << (IDENTITY_VALUE - 535)) | (1L << (INT - 535)) | (1L << (LAST - 535)) | (1L << (LAST_VALUE - 535)) | (1L << (LOW - 535)) | (1L << (MAX - 535)) | (1L << (MIN - 535)) | (1L << (MINUTES - 535)))) != 0) || _la==NUMBER || ((((_la - 695)) & ~0x3f) == 0 && ((1L << (_la - 695)) & ((1L << (ROW - 695)) | (1L << (ROW_NUMBER - 695)) | (1L << (SUM - 695)) | (1L << (TIME - 695)))) != 0) || _la==ID) {
						{
						setState(216);
						((Table_nameContext)_localctx).schema = id();
						}
					}

					setState(219);
					match(DOT);
					}
					break;
				case 2:
					{
					setState(221);
					((Table_nameContext)_localctx).schema = id();
					setState(222);
					match(DOT);
					}
					break;
				}
				setState(226);
				((Table_nameContext)_localctx).table = id();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(237);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,26,_ctx) ) {
				case 1:
					{
					setState(227);
					((Table_nameContext)_localctx).database = id();
					setState(228);
					match(DOT);
					setState(230);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==INIT || _la==ROWCOUNT || ((((_la - 394)) & ~0x3f) == 0 && ((1L << (_la - 394)) & ((1L << (AGGREGATE - 394)) | (1L << (AVG - 394)) | (1L << (BIGINT - 394)) | (1L << (BINARY_BASE64 - 394)) | (1L << (COUNT - 394)) | (1L << (COUNT_BIG - 394)) | (1L << (COUNTER - 394)))) != 0) || ((((_la - 458)) & ~0x3f) == 0 && ((1L << (_la - 458)) & ((1L << (DATEADD - 458)) | (1L << (DATEDIFF - 458)) | (1L << (DATENAME - 458)) | (1L << (DATEPART - 458)) | (1L << (DAYS - 458)) | (1L << (FIRST - 458)) | (1L << (FIRST_VALUE - 458)) | (1L << (FOLLOWING - 458)))) != 0) || ((((_la - 535)) & ~0x3f) == 0 && ((1L << (_la - 535)) & ((1L << (HOURS - 535)) | (1L << (IDENTITY_VALUE - 535)) | (1L << (INT - 535)) | (1L << (LAST - 535)) | (1L << (LAST_VALUE - 535)) | (1L << (LOW - 535)) | (1L << (MAX - 535)) | (1L << (MIN - 535)) | (1L << (MINUTES - 535)))) != 0) || _la==NUMBER || ((((_la - 695)) & ~0x3f) == 0 && ((1L << (_la - 695)) & ((1L << (ROW - 695)) | (1L << (ROW_NUMBER - 695)) | (1L << (SUM - 695)) | (1L << (TIME - 695)))) != 0) || _la==ID) {
						{
						setState(229);
						((Table_nameContext)_localctx).schema = id();
						}
					}

					setState(232);
					match(DOT);
					}
					break;
				case 2:
					{
					setState(234);
					((Table_nameContext)_localctx).schema = id();
					setState(235);
					match(DOT);
					}
					break;
				}
				setState(239);
				match(BLOCKING_HIERARCHY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Primitive_expressionContext extends ParserRuleContext {
		public TerminalNode DEFAULT() { return getToken(SelectParts.DEFAULT, 0); }
		public TerminalNode NULL() { return getToken(SelectParts.NULL, 0); }
		public TerminalNode LOCAL_ID() { return getToken(SelectParts.LOCAL_ID, 0); }
		public ConstantContext constant() {
			return getRuleContext(ConstantContext.class,0);
		}
		public Primitive_expressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_primitive_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterPrimitive_expression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitPrimitive_expression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitPrimitive_expression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Primitive_expressionContext primitive_expression() throws RecognitionException {
		Primitive_expressionContext _localctx = new Primitive_expressionContext(_ctx, getState());
		enterRule(_localctx, 34, RULE_primitive_expression);
		try {
			setState(246);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case DEFAULT:
				enterOuterAlt(_localctx, 1);
				{
				setState(242);
				match(DEFAULT);
				}
				break;
			case NULL:
				enterOuterAlt(_localctx, 2);
				{
				setState(243);
				match(NULL);
				}
				break;
			case LOCAL_ID:
				enterOuterAlt(_localctx, 3);
				{
				setState(244);
				match(LOCAL_ID);
				}
				break;
			case DECIMAL:
			case STRING:
			case BINARY:
			case FLOAT:
			case REAL:
			case PLUS:
			case MINUS:
				enterOuterAlt(_localctx, 4);
				{
				setState(245);
				constant();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Unary_operator_expressionContext extends ParserRuleContext {
		public Token op;
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public Unary_operator_expressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_unary_operator_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterUnary_operator_expression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitUnary_operator_expression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitUnary_operator_expression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Unary_operator_expressionContext unary_operator_expression() throws RecognitionException {
		Unary_operator_expressionContext _localctx = new Unary_operator_expressionContext(_ctx, getState());
		enterRule(_localctx, 36, RULE_unary_operator_expression);
		int _la;
		try {
			setState(252);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case BIT_NOT:
				enterOuterAlt(_localctx, 1);
				{
				setState(248);
				match(BIT_NOT);
				setState(249);
				expression(0);
				}
				break;
			case PLUS:
			case MINUS:
				enterOuterAlt(_localctx, 2);
				{
				setState(250);
				((Unary_operator_expressionContext)_localctx).op = _input.LT(1);
				_la = _input.LA(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
					((Unary_operator_expressionContext)_localctx).op = (Token)_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(251);
				expression(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Bracket_expressionContext extends ParserRuleContext {
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public Bracket_expressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_bracket_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterBracket_expression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitBracket_expression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitBracket_expression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Bracket_expressionContext bracket_expression() throws RecognitionException {
		Bracket_expressionContext _localctx = new Bracket_expressionContext(_ctx, getState());
		enterRule(_localctx, 38, RULE_bracket_expression);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(254);
			match(LR_BRACKET);
			setState(255);
			expression(0);
			setState(256);
			match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Constant_expressionContext extends ParserRuleContext {
		public TerminalNode NULL() { return getToken(SelectParts.NULL, 0); }
		public ConstantContext constant() {
			return getRuleContext(ConstantContext.class,0);
		}
		public Function_callContext function_call() {
			return getRuleContext(Function_callContext.class,0);
		}
		public Constant_expressionContext constant_expression() {
			return getRuleContext(Constant_expressionContext.class,0);
		}
		public Constant_expressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_constant_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterConstant_expression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitConstant_expression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitConstant_expression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Constant_expressionContext constant_expression() throws RecognitionException {
		Constant_expressionContext _localctx = new Constant_expressionContext(_ctx, getState());
		enterRule(_localctx, 40, RULE_constant_expression);
		try {
			setState(265);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case NULL:
				enterOuterAlt(_localctx, 1);
				{
				setState(258);
				match(NULL);
				}
				break;
			case DECIMAL:
			case STRING:
			case BINARY:
			case FLOAT:
			case REAL:
			case PLUS:
			case MINUS:
				enterOuterAlt(_localctx, 2);
				{
				setState(259);
				constant();
				}
				break;
			case INIT:
			case ROWCOUNT:
			case AGGREGATE:
			case AVG:
			case BIGINT:
			case BINARY_BASE64:
			case COUNT:
			case COUNT_BIG:
			case COUNTER:
			case DATEADD:
			case DATEDIFF:
			case DATENAME:
			case DATEPART:
			case DAYS:
			case FIRST:
			case FIRST_VALUE:
			case FOLLOWING:
			case HOURS:
			case IDENTITY_VALUE:
			case INT:
			case LAST:
			case LAST_VALUE:
			case LOW:
			case MAX:
			case MIN:
			case MINUTES:
			case NUMBER:
			case ROW:
			case ROW_NUMBER:
			case STDEV:
			case STDEVP:
			case SUM:
			case TIME:
			case VAR:
			case VARP:
			case ID:
				enterOuterAlt(_localctx, 3);
				{
				setState(260);
				function_call();
				}
				break;
			case LR_BRACKET:
				enterOuterAlt(_localctx, 4);
				{
				setState(261);
				match(LR_BRACKET);
				setState(262);
				constant_expression();
				setState(263);
				match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Comparison_operatorContext extends ParserRuleContext {
		public Comparison_operatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_comparison_operator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterComparison_operator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitComparison_operator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitComparison_operator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Comparison_operatorContext comparison_operator() throws RecognitionException {
		Comparison_operatorContext _localctx = new Comparison_operatorContext(_ctx, getState());
		enterRule(_localctx, 42, RULE_comparison_operator);
		try {
			setState(282);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,31,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(267);
				match(EQUAL);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(268);
				match(GREATER);
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(269);
				match(LESS);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(270);
				match(LESS);
				setState(271);
				match(EQUAL);
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(272);
				match(GREATER);
				setState(273);
				match(EQUAL);
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(274);
				match(LESS);
				setState(275);
				match(GREATER);
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(276);
				match(EXCLAMATION);
				setState(277);
				match(EQUAL);
				}
				break;
			case 8:
				enterOuterAlt(_localctx, 8);
				{
				setState(278);
				match(EXCLAMATION);
				setState(279);
				match(GREATER);
				}
				break;
			case 9:
				enterOuterAlt(_localctx, 9);
				{
				setState(280);
				match(EXCLAMATION);
				setState(281);
				match(LESS);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Assignment_operatorContext extends ParserRuleContext {
		public Assignment_operatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_assignment_operator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterAssignment_operator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitAssignment_operator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitAssignment_operator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Assignment_operatorContext assignment_operator() throws RecognitionException {
		Assignment_operatorContext _localctx = new Assignment_operatorContext(_ctx, getState());
		enterRule(_localctx, 44, RULE_assignment_operator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(284);
			_la = _input.LA(1);
			if ( !(((((_la - 805)) & ~0x3f) == 0 && ((1L << (_la - 805)) & ((1L << (PLUS_ASSIGN - 805)) | (1L << (MINUS_ASSIGN - 805)) | (1L << (MULT_ASSIGN - 805)) | (1L << (DIV_ASSIGN - 805)) | (1L << (MOD_ASSIGN - 805)) | (1L << (AND_ASSIGN - 805)) | (1L << (XOR_ASSIGN - 805)) | (1L << (OR_ASSIGN - 805)))) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Null_notnullContext extends ParserRuleContext {
		public TerminalNode NULL() { return getToken(SelectParts.NULL, 0); }
		public TerminalNode NOT() { return getToken(SelectParts.NOT, 0); }
		public Null_notnullContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_null_notnull; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterNull_notnull(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitNull_notnull(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitNull_notnull(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Null_notnullContext null_notnull() throws RecognitionException {
		Null_notnullContext _localctx = new Null_notnullContext(_ctx, getState());
		enterRule(_localctx, 46, RULE_null_notnull);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(287);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==NOT) {
				{
				setState(286);
				match(NOT);
				}
			}

			setState(289);
			match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ConstantContext extends ParserRuleContext {
		public TerminalNode STRING() { return getToken(SelectParts.STRING, 0); }
		public TerminalNode BINARY() { return getToken(SelectParts.BINARY, 0); }
		public TerminalNode DECIMAL() { return getToken(SelectParts.DECIMAL, 0); }
		public SignContext sign() {
			return getRuleContext(SignContext.class,0);
		}
		public TerminalNode REAL() { return getToken(SelectParts.REAL, 0); }
		public TerminalNode FLOAT() { return getToken(SelectParts.FLOAT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_constant; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterConstant(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitConstant(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitConstant(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConstantContext constant() throws RecognitionException {
		ConstantContext _localctx = new ConstantContext(_ctx, getState());
		enterRule(_localctx, 48, RULE_constant);
		int _la;
		try {
			setState(301);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,35,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(291);
				match(STRING);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(292);
				match(BINARY);
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(294);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==PLUS || _la==MINUS) {
					{
					setState(293);
					sign();
					}
				}

				setState(296);
				match(DECIMAL);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(298);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==PLUS || _la==MINUS) {
					{
					setState(297);
					sign();
					}
				}

				setState(300);
				_la = _input.LA(1);
				if ( !(_la==FLOAT || _la==REAL) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class SignContext extends ParserRuleContext {
		public SignContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_sign; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterSign(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitSign(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitSign(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SignContext sign() throws RecognitionException {
		SignContext _localctx = new SignContext(_ctx, getState());
		enterRule(_localctx, 50, RULE_sign);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(303);
			_la = _input.LA(1);
			if ( !(_la==PLUS || _la==MINUS) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class IdContext extends ParserRuleContext {
		public TerminalNode ID() { return getToken(SelectParts.ID, 0); }
		public TerminalNode AGGREGATE() { return getToken(SelectParts.AGGREGATE, 0); }
		public TerminalNode AVG() { return getToken(SelectParts.AVG, 0); }
		public TerminalNode BIGINT() { return getToken(SelectParts.BIGINT, 0); }
		public TerminalNode BINARY_BASE64() { return getToken(SelectParts.BINARY_BASE64, 0); }
		public TerminalNode COUNT() { return getToken(SelectParts.COUNT, 0); }
		public TerminalNode COUNT_BIG() { return getToken(SelectParts.COUNT_BIG, 0); }
		public TerminalNode COUNTER() { return getToken(SelectParts.COUNTER, 0); }
		public TerminalNode DATEADD() { return getToken(SelectParts.DATEADD, 0); }
		public TerminalNode DATEDIFF() { return getToken(SelectParts.DATEDIFF, 0); }
		public TerminalNode DATENAME() { return getToken(SelectParts.DATENAME, 0); }
		public TerminalNode DATEPART() { return getToken(SelectParts.DATEPART, 0); }
		public TerminalNode DAYS() { return getToken(SelectParts.DAYS, 0); }
		public TerminalNode FIRST() { return getToken(SelectParts.FIRST, 0); }
		public TerminalNode FIRST_VALUE() { return getToken(SelectParts.FIRST_VALUE, 0); }
		public TerminalNode FOLLOWING() { return getToken(SelectParts.FOLLOWING, 0); }
		public TerminalNode HOURS() { return getToken(SelectParts.HOURS, 0); }
		public TerminalNode IDENTITY_VALUE() { return getToken(SelectParts.IDENTITY_VALUE, 0); }
		public TerminalNode INIT() { return getToken(SelectParts.INIT, 0); }
		public TerminalNode INT() { return getToken(SelectParts.INT, 0); }
		public TerminalNode LAST() { return getToken(SelectParts.LAST, 0); }
		public TerminalNode LAST_VALUE() { return getToken(SelectParts.LAST_VALUE, 0); }
		public TerminalNode LOW() { return getToken(SelectParts.LOW, 0); }
		public TerminalNode MAX() { return getToken(SelectParts.MAX, 0); }
		public TerminalNode MIN() { return getToken(SelectParts.MIN, 0); }
		public TerminalNode MINUTES() { return getToken(SelectParts.MINUTES, 0); }
		public TerminalNode NUMBER() { return getToken(SelectParts.NUMBER, 0); }
		public TerminalNode ROW() { return getToken(SelectParts.ROW, 0); }
		public TerminalNode ROW_NUMBER() { return getToken(SelectParts.ROW_NUMBER, 0); }
		public TerminalNode ROWCOUNT() { return getToken(SelectParts.ROWCOUNT, 0); }
		public TerminalNode SUM() { return getToken(SelectParts.SUM, 0); }
		public TerminalNode TIME() { return getToken(SelectParts.TIME, 0); }
		public IdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_id; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).enterId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SelectPartsListener ) ((SelectPartsListener)listener).exitId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SelectPartsVisitor ) return ((SelectPartsVisitor<? extends T>)visitor).visitId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final IdContext id() throws RecognitionException {
		IdContext _localctx = new IdContext(_ctx, getState());
		enterRule(_localctx, 52, RULE_id);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(305);
			_la = _input.LA(1);
			if ( !(_la==INIT || _la==ROWCOUNT || ((((_la - 394)) & ~0x3f) == 0 && ((1L << (_la - 394)) & ((1L << (AGGREGATE - 394)) | (1L << (AVG - 394)) | (1L << (BIGINT - 394)) | (1L << (BINARY_BASE64 - 394)) | (1L << (COUNT - 394)) | (1L << (COUNT_BIG - 394)) | (1L << (COUNTER - 394)))) != 0) || ((((_la - 458)) & ~0x3f) == 0 && ((1L << (_la - 458)) & ((1L << (DATEADD - 458)) | (1L << (DATEDIFF - 458)) | (1L << (DATENAME - 458)) | (1L << (DATEPART - 458)) | (1L << (DAYS - 458)) | (1L << (FIRST - 458)) | (1L << (FIRST_VALUE - 458)) | (1L << (FOLLOWING - 458)))) != 0) || ((((_la - 535)) & ~0x3f) == 0 && ((1L << (_la - 535)) & ((1L << (HOURS - 535)) | (1L << (IDENTITY_VALUE - 535)) | (1L << (INT - 535)) | (1L << (LAST - 535)) | (1L << (LAST_VALUE - 535)) | (1L << (LOW - 535)) | (1L << (MAX - 535)) | (1L << (MIN - 535)) | (1L << (MINUTES - 535)))) != 0) || _la==NUMBER || ((((_la - 695)) & ~0x3f) == 0 && ((1L << (_la - 695)) & ((1L << (ROW - 695)) | (1L << (ROW_NUMBER - 695)) | (1L << (SUM - 695)) | (1L << (TIME - 695)))) != 0) || _la==ID) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 11:
			return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private boolean expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0:
			return precpred(_ctx, 4);
		case 1:
			return precpred(_ctx, 3);
		case 2:
			return precpred(_ctx, 2);
		case 3:
			return precpred(_ctx, 1);
		}
		return true;
	}

	public static final String _serializedATN =
		"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0343\u0136\4\2\t"+
		"\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13"+
		"\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22"+
		"\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31\t\31"+
		"\4\32\t\32\4\33\t\33\4\34\t\34\3\2\3\2\3\2\7\2<\n\2\f\2\16\2?\13\2\3\3"+
		"\3\3\3\3\3\3\5\3E\n\3\5\3G\n\3\3\4\5\4J\n\4\3\4\3\4\3\5\3\5\5\5P\n\5\3"+
		"\6\3\6\3\6\5\6U\n\6\3\6\3\6\5\6Y\n\6\3\7\3\7\3\7\3\7\3\7\5\7`\n\7\3\b"+
		"\3\b\3\b\7\be\n\b\f\b\16\bh\13\b\3\t\3\t\3\t\7\tm\n\t\f\t\16\tp\13\t\3"+
		"\n\5\ns\n\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3\13\5\13}\n\13\3\13\3\13"+
		"\3\13\3\13\3\13\3\13\3\13\5\13\u0086\n\13\3\13\3\13\3\13\3\13\3\13\3\13"+
		"\3\13\3\13\3\13\3\13\3\13\5\13\u0093\n\13\3\f\3\f\3\f\7\f\u0098\n\f\f"+
		"\f\16\f\u009b\13\f\3\r\3\r\3\r\3\r\3\r\3\r\5\r\u00a3\n\r\3\r\3\r\3\r\3"+
		"\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\7\r\u00b3\n\r\f\r\16\r\u00b6"+
		"\13\r\3\16\3\16\3\16\3\16\5\16\u00bc\n\16\3\16\3\16\5\16\u00c0\n\16\3"+
		"\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\5\17\u00cb\n\17\3\17\5\17"+
		"\u00ce\n\17\3\20\3\20\3\21\3\21\3\21\5\21\u00d5\n\21\3\21\3\21\3\22\3"+
		"\22\3\22\5\22\u00dc\n\22\3\22\3\22\3\22\3\22\3\22\5\22\u00e3\n\22\3\22"+
		"\3\22\3\22\3\22\5\22\u00e9\n\22\3\22\3\22\3\22\3\22\3\22\5\22\u00f0\n"+
		"\22\3\22\5\22\u00f3\n\22\3\23\3\23\3\23\3\23\5\23\u00f9\n\23\3\24\3\24"+
		"\3\24\3\24\5\24\u00ff\n\24\3\25\3\25\3\25\3\25\3\26\3\26\3\26\3\26\3\26"+
		"\3\26\3\26\5\26\u010c\n\26\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27"+
		"\3\27\3\27\3\27\3\27\3\27\3\27\5\27\u011d\n\27\3\30\3\30\3\31\5\31\u0122"+
		"\n\31\3\31\3\31\3\32\3\32\3\32\5\32\u0129\n\32\3\32\3\32\5\32\u012d\n"+
		"\32\3\32\5\32\u0130\n\32\3\33\3\33\3\34\3\34\3\34\2\3\30\35\2\4\6\b\n"+
		"\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\66\2\n\3\2\u033a\u033c"+
		"\5\2\u032f\u032f\u033d\u033e\u0340\u0342\b\2\u01a3\u01a3\u0242\u0242\u0252"+
		"\u0252\u02df\u02e0\u02e4\u02e4\u0305\u0306\3\2\u01c1\u01c2\3\2\u033d\u033e"+
		"\3\2\u0327\u032e\3\2\u0321\u0322\26\2\u00a0\u00a0\u0122\u0122\u018c\u018c"+
		"\u01a3\u01a3\u01a6\u01a7\u01c1\u01c3\u01cc\u01d0\u0202\u0204\u0219\u021a"+
		"\u0225\u0225\u0230\u0231\u023e\u023e\u0242\u0242\u0252\u0252\u0257\u0257"+
		"\u0270\u0270\u02b9\u02ba\u02e4\u02e4\u02ef\u02ef\u031c\u031c\2\u0156\2"+
		"8\3\2\2\2\4F\3\2\2\2\6I\3\2\2\2\bO\3\2\2\2\nT\3\2\2\2\f_\3\2\2\2\16a\3"+
		"\2\2\2\20i\3\2\2\2\22r\3\2\2\2\24\u0092\3\2\2\2\26\u0094\3\2\2\2\30\u00a2"+
		"\3\2\2\2\32\u00bf\3\2\2\2\34\u00cd\3\2\2\2\36\u00cf\3\2\2\2 \u00d4\3\2"+
		"\2\2\"\u00f2\3\2\2\2$\u00f8\3\2\2\2&\u00fe\3\2\2\2(\u0100\3\2\2\2*\u010b"+
		"\3\2\2\2,\u011c\3\2\2\2.\u011e\3\2\2\2\60\u0121\3\2\2\2\62\u012f\3\2\2"+
		"\2\64\u0131\3\2\2\2\66\u0133\3\2\2\28=\5\4\3\29:\7\u0337\2\2:<\5\4\3\2"+
		";9\3\2\2\2<?\3\2\2\2=;\3\2\2\2=>\3\2\2\2>\3\3\2\2\2?=\3\2\2\2@G\5\f\7"+
		"\2AG\5\n\6\2BD\5\30\r\2CE\5\6\4\2DC\3\2\2\2DE\3\2\2\2EG\3\2\2\2F@\3\2"+
		"\2\2FA\3\2\2\2FB\3\2\2\2G\5\3\2\2\2HJ\7\20\2\2IH\3\2\2\2IJ\3\2\2\2JK\3"+
		"\2\2\2KL\5\b\5\2L\7\3\2\2\2MP\5\66\34\2NP\7\u031f\2\2OM\3\2\2\2ON\3\2"+
		"\2\2P\t\3\2\2\2QR\5\"\22\2RS\7\u0330\2\2SU\3\2\2\2TQ\3\2\2\2TU\3\2\2\2"+
		"UV\3\2\2\2VX\5\66\34\2WY\5\6\4\2XW\3\2\2\2XY\3\2\2\2Y\13\3\2\2\2Z`\7\u033a"+
		"\2\2[\\\5\"\22\2\\]\7\u0330\2\2]^\5\f\7\2^`\3\2\2\2_Z\3\2\2\2_[\3\2\2"+
		"\2`\r\3\2\2\2af\5\20\t\2bc\7\u00ed\2\2ce\5\20\t\2db\3\2\2\2eh\3\2\2\2"+
		"fd\3\2\2\2fg\3\2\2\2g\17\3\2\2\2hf\3\2\2\2in\5\22\n\2jk\7\13\2\2km\5\22"+
		"\n\2lj\3\2\2\2mp\3\2\2\2nl\3\2\2\2no\3\2\2\2o\21\3\2\2\2pn\3\2\2\2qs\7"+
		"\u00dc\2\2rq\3\2\2\2rs\3\2\2\2st\3\2\2\2tu\5\24\13\2u\23\3\2\2\2vw\5\30"+
		"\r\2wx\5,\27\2xy\5\30\r\2y\u0093\3\2\2\2z|\5\30\r\2{}\7\u00dc\2\2|{\3"+
		"\2\2\2|}\3\2\2\2}~\3\2\2\2~\177\7\u009b\2\2\177\u0080\7\u0335\2\2\u0080"+
		"\u0081\5\26\f\2\u0081\u0082\7\u0336\2\2\u0082\u0093\3\2\2\2\u0083\u0085"+
		"\5\30\r\2\u0084\u0086\7\u00dc\2\2\u0085\u0084\3\2\2\2\u0085\u0086\3\2"+
		"\2\2\u0086\u0087\3\2\2\2\u0087\u0088\7\u00b4\2\2\u0088\u0089\5\30\r\2"+
		"\u0089\u0093\3\2\2\2\u008a\u008b\5\30\r\2\u008b\u008c\7\u00a8\2\2\u008c"+
		"\u008d\5\60\31\2\u008d\u0093\3\2\2\2\u008e\u008f\7\u0335\2\2\u008f\u0090"+
		"\5\16\b\2\u0090\u0091\7\u0336\2\2\u0091\u0093\3\2\2\2\u0092v\3\2\2\2\u0092"+
		"z\3\2\2\2\u0092\u0083\3\2\2\2\u0092\u008a\3\2\2\2\u0092\u008e\3\2\2\2"+
		"\u0093\25\3\2\2\2\u0094\u0099\5\30\r\2\u0095\u0096\7\u0337\2\2\u0096\u0098"+
		"\5\30\r\2\u0097\u0095\3\2\2\2\u0098\u009b\3\2\2\2\u0099\u0097\3\2\2\2"+
		"\u0099\u009a\3\2\2\2\u009a\27\3\2\2\2\u009b\u0099\3\2\2\2\u009c\u009d"+
		"\b\r\1\2\u009d\u00a3\5$\23\2\u009e\u00a3\5\32\16\2\u009f\u00a3\5 \21\2"+
		"\u00a0\u00a3\5(\25\2\u00a1\u00a3\5&\24\2\u00a2\u009c\3\2\2\2\u00a2\u009e"+
		"\3\2\2\2\u00a2\u009f\3\2\2\2\u00a2\u00a0\3\2\2\2\u00a2\u00a1\3\2\2\2\u00a3"+
		"\u00b4\3\2\2\2\u00a4\u00a5\f\6\2\2\u00a5\u00a6\t\2\2\2\u00a6\u00b3\5\30"+
		"\r\7\u00a7\u00a8\f\5\2\2\u00a8\u00a9\t\3\2\2\u00a9\u00b3\5\30\r\6\u00aa"+
		"\u00ab\f\4\2\2\u00ab\u00ac\5,\27\2\u00ac\u00ad\5\30\r\5\u00ad\u00b3\3"+
		"\2\2\2\u00ae\u00af\f\3\2\2\u00af\u00b0\5.\30\2\u00b0\u00b1\5\30\r\4\u00b1"+
		"\u00b3\3\2\2\2\u00b2\u00a4\3\2\2\2\u00b2\u00a7\3\2\2\2\u00b2\u00aa\3\2"+
		"\2\2\u00b2\u00ae\3\2\2\2\u00b3\u00b6\3\2\2\2\u00b4\u00b2\3\2\2\2\u00b4"+
		"\u00b5\3\2\2\2\u00b5\31\3\2\2\2\u00b6\u00b4\3\2\2\2\u00b7\u00c0\5\34\17"+
		"\2\u00b8\u00b9\5\36\20\2\u00b9\u00bb\7\u0335\2\2\u00ba\u00bc\5\26\f\2"+
		"\u00bb\u00ba\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc\u00bd\3\2\2\2\u00bd\u00be"+
		"\7\u0336\2\2\u00be\u00c0\3\2\2\2\u00bf\u00b7\3\2\2\2\u00bf\u00b8\3\2\2"+
		"\2\u00c0\33\3\2\2\2\u00c1\u00c2\t\4\2\2\u00c2\u00c3\7\u0335\2\2\u00c3"+
		"\u00c4\5 \21\2\u00c4\u00c5\7\u0336\2\2\u00c5\u00ce\3\2\2\2\u00c6\u00c7"+
		"\t\5\2\2\u00c7\u00ca\7\u0335\2\2\u00c8\u00cb\7\u033a\2\2\u00c9\u00cb\5"+
		" \21\2\u00ca\u00c8\3\2\2\2\u00ca\u00c9\3\2\2\2\u00cb\u00cc\3\2\2\2\u00cc"+
		"\u00ce\7\u0336\2\2\u00cd\u00c1\3\2\2\2\u00cd\u00c6\3\2\2\2\u00ce\35\3"+
		"\2\2\2\u00cf\u00d0\5\66\34\2\u00d0\37\3\2\2\2\u00d1\u00d2\5\"\22\2\u00d2"+
		"\u00d3\7\u0330\2\2\u00d3\u00d5\3\2\2\2\u00d4\u00d1\3\2\2\2\u00d4\u00d5"+
		"\3\2\2\2\u00d5\u00d6\3\2\2\2\u00d6\u00d7\5\66\34\2\u00d7!\3\2\2\2\u00d8"+
		"\u00d9\5\66\34\2\u00d9\u00db\7\u0330\2\2\u00da\u00dc\5\66\34\2\u00db\u00da"+
		"\3\2\2\2\u00db\u00dc\3\2\2\2\u00dc\u00dd\3\2\2\2\u00dd\u00de\7\u0330\2"+
		"\2\u00de\u00e3\3\2\2\2\u00df\u00e0\5\66\34\2\u00e0\u00e1\7\u0330\2\2\u00e1"+
		"\u00e3\3\2\2\2\u00e2\u00d8\3\2\2\2\u00e2\u00df\3\2\2\2\u00e2\u00e3\3\2"+
		"\2\2\u00e3\u00e4\3\2\2\2\u00e4\u00f3\5\66\34\2\u00e5\u00e6\5\66\34\2\u00e6"+
		"\u00e8\7\u0330\2\2\u00e7\u00e9\5\66\34\2\u00e8\u00e7\3\2\2\2\u00e8\u00e9"+
		"\3\2\2\2\u00e9\u00ea\3\2\2\2\u00ea\u00eb\7\u0330\2\2\u00eb\u00f0\3\2\2"+
		"\2\u00ec\u00ed\5\66\34\2\u00ed\u00ee\7\u0330\2\2\u00ee\u00f0\3\2\2\2\u00ef"+
		"\u00e5\3\2\2\2\u00ef\u00ec\3\2\2\2\u00ef\u00f0\3\2\2\2\u00f0\u00f1\3\2"+
		"\2\2\u00f1\u00f3\7 \2\2\u00f2\u00e2\3\2\2\2\u00f2\u00ef\3\2\2\2\u00f3"+
		"#\3\2\2\2\u00f4\u00f9\7Z\2\2\u00f5\u00f9\7\u00df\2\2\u00f6\u00f9\7\u031a"+
		"\2\2\u00f7\u00f9\5\62\32\2\u00f8\u00f4\3\2\2\2\u00f8\u00f5\3\2\2\2\u00f8"+
		"\u00f6\3\2\2\2\u00f8\u00f7\3\2\2\2\u00f9%\3\2\2\2\u00fa\u00fb\7\u033f"+
		"\2\2\u00fb\u00ff\5\30\r\2\u00fc\u00fd\t\6\2\2\u00fd\u00ff\5\30\r\2\u00fe"+
		"\u00fa\3\2\2\2\u00fe\u00fc\3\2\2\2\u00ff\'\3\2\2\2\u0100\u0101\7\u0335"+
		"\2\2\u0101\u0102\5\30\r\2\u0102\u0103\7\u0336\2\2\u0103)\3\2\2\2\u0104"+
		"\u010c\7\u00df\2\2\u0105\u010c\5\62\32\2\u0106\u010c\5\32\16\2\u0107\u0108"+
		"\7\u0335\2\2\u0108\u0109\5*\26\2\u0109\u010a\7\u0336\2\2\u010a\u010c\3"+
		"\2\2\2\u010b\u0104\3\2\2\2\u010b\u0105\3\2\2\2\u010b\u0106\3\2\2\2\u010b"+
		"\u0107\3\2\2\2\u010c+\3\2\2\2\u010d\u011d\7\u0323\2\2\u010e\u011d\7\u0324"+
		"\2\2\u010f\u011d\7\u0325\2\2\u0110\u0111\7\u0325\2\2\u0111\u011d\7\u0323"+
		"\2\2\u0112\u0113\7\u0324\2\2\u0113\u011d\7\u0323\2\2\u0114\u0115\7\u0325"+
		"\2\2\u0115\u011d\7\u0324\2\2\u0116\u0117\7\u0326\2\2\u0117\u011d\7\u0323"+
		"\2\2\u0118\u0119\7\u0326\2\2\u0119\u011d\7\u0324\2\2\u011a\u011b\7\u0326"+
		"\2\2\u011b\u011d\7\u0325\2\2\u011c\u010d\3\2\2\2\u011c\u010e\3\2\2\2\u011c"+
		"\u010f\3\2\2\2\u011c\u0110\3\2\2\2\u011c\u0112\3\2\2\2\u011c\u0114\3\2"+
		"\2\2\u011c\u0116\3\2\2\2\u011c\u0118\3\2\2\2\u011c\u011a\3\2\2\2\u011d"+
		"-\3\2\2\2\u011e\u011f\t\7\2\2\u011f/\3\2\2\2\u0120\u0122\7\u00dc\2\2\u0121"+
		"\u0120\3\2\2\2\u0121\u0122\3\2\2\2\u0122\u0123\3\2\2\2\u0123\u0124\7\u00df"+
		"\2\2\u0124\61\3\2\2\2\u0125\u0130\7\u031f\2\2\u0126\u0130\7\u0320\2\2"+
		"\u0127\u0129\5\64\33\2\u0128\u0127\3\2\2\2\u0128\u0129\3\2\2\2\u0129\u012a"+
		"\3\2\2\2\u012a\u0130\7\u031b\2\2\u012b\u012d\5\64\33\2\u012c\u012b\3\2"+
		"\2\2\u012c\u012d\3\2\2\2\u012d\u012e\3\2\2\2\u012e\u0130\t\b\2\2\u012f"+
		"\u0125\3\2\2\2\u012f\u0126\3\2\2\2\u012f\u0128\3\2\2\2\u012f\u012c\3\2"+
		"\2\2\u0130\63\3\2\2\2\u0131\u0132\t\6\2\2\u0132\65\3\2\2\2\u0133\u0134"+
		"\t\t\2\2\u0134\67\3\2\2\2&=DFIOTX_fnr|\u0085\u0092\u0099\u00a2\u00b2\u00b4"+
		"\u00bb\u00bf\u00ca\u00cd\u00d4\u00db\u00e2\u00e8\u00ef\u00f2\u00f8\u00fe"+
		"\u010b\u011c\u0121\u0128\u012c\u012f";
	public static final ATN _ATN =
		new ATNDeserializer().deserialize(_serializedATN.toCharArray());
	static {
		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
		for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
		}
	}
}