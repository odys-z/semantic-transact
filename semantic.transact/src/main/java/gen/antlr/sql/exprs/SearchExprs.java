// Generated from SearchExprs.g4 by ANTLR 4.7.1
package gen.antlr.sql.exprs;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.v4.runtime.tree.*;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast"})
public class SearchExprs extends Parser {
	static { RuntimeMetaData.checkVersion("4.7.1", RuntimeMetaData.VERSION); }

	protected static final DFA[] _decisionToDFA;
	protected static final PredictionContextCache _sharedContextCache =
		new PredictionContextCache();
	public static final int
		ABSENT=1, ADD=2, AES=3, ALL=4, ALLOW_CONNECTIONS=5, ALLOW_MULTIPLE_EVENT_LOSS=6, 
		ALLOW_SINGLE_EVENT_LOSS=7, ALTER=8, AND=9, ANONYMOUS=10, ANY=11, APPEND=12, 
		APPLICATION=13, AS=14, ASC=15, ASYMMETRIC=16, ASYNCHRONOUS_COMMIT=17, 
		AUTHORIZATION=18, AUTHENTICATION=19, AUTOMATED_BACKUP_PREFERENCE=20, AUTOMATIC=21, 
		AVAILABILITY_MODE=22, BACKSLASH=23, BACKUP=24, BEFORE=25, BEGIN=26, BETWEEN=27, 
		BLOCK=28, BLOCKSIZE=29, BLOCKING_HIERARCHY=30, BREAK=31, BROWSE=32, BUFFER=33, 
		BUFFERCOUNT=34, BULK=35, BY=36, CACHE=37, CALLED=38, CASCADE=39, CASE=40, 
		CERTIFICATE=41, CHANGETABLE=42, CHANGES=43, CHECK=44, CHECKPOINT=45, CHECK_POLICY=46, 
		CHECK_EXPIRATION=47, CLASSIFIER_FUNCTION=48, CLOSE=49, CLUSTER=50, CLUSTERED=51, 
		COALESCE=52, COLLATE=53, COLUMN=54, COMPRESSION=55, COMMIT=56, COMPUTE=57, 
		CONFIGURATION=58, CONSTRAINT=59, CONTAINMENT=60, CONTAINS=61, CONTAINSTABLE=62, 
		CONTEXT=63, CONTINUE=64, CONTINUE_AFTER_ERROR=65, CONTRACT=66, CONTRACT_NAME=67, 
		CONVERSATION=68, CONVERT=69, COPY_ONLY=70, CREATE=71, CROSS=72, CURRENT=73, 
		CURRENT_DATE=74, CURRENT_TIME=75, CURRENT_TIMESTAMP=76, CURRENT_USER=77, 
		CURSOR=78, CYCLE=79, DATA=80, DATA_COMPRESSION=81, DATA_SOURCE=82, DATABASE=83, 
		DATABASE_MIRRORING=84, DBCC=85, DEALLOCATE=86, DECLARE=87, DEFAULT=88, 
		DEFAULT_DATABASE=89, DEFAULT_SCHEMA=90, DELETE=91, DENY=92, DESC=93, DIAGNOSTICS=94, 
		DIFFERENTIAL=95, DISK=96, DISTINCT=97, DISTRIBUTED=98, DOUBLE=99, DOUBLE_BACK_SLASH=100, 
		DOUBLE_FORWARD_SLASH=101, DROP=102, DTC_SUPPORT=103, DUMP=104, ELSE=105, 
		ENABLED=106, END=107, ENDPOINT=108, ERRLVL=109, ESCAPE=110, ERROR=111, 
		EVENT=112, EVENTDATA=113, EVENT_RETENTION_MODE=114, EXCEPT=115, EXECUTABLE_FILE=116, 
		EXECUTE=117, EXISTS=118, EXPIREDATE=119, EXIT=120, EXTENSION=121, EXTERNAL=122, 
		EXTERNAL_ACCESS=123, FAILOVER=124, FAILURECONDITIONLEVEL=125, FAN_IN=126, 
		FETCH=127, FILE=128, FILENAME=129, FILLFACTOR=130, FILE_SNAPSHOT=131, 
		FOR=132, FORCESEEK=133, FORCE_SERVICE_ALLOW_DATA_LOSS=134, FOREIGN=135, 
		FREETEXT=136, FREETEXTTABLE=137, FROM=138, FULL=139, FUNCTION=140, GET=141, 
		GOTO=142, GOVERNOR=143, GRANT=144, GROUP=145, HAVING=146, HASHED=147, 
		HEALTHCHECKTIMEOUT=148, IDENTITY=149, IDENTITYCOL=150, IDENTITY_INSERT=151, 
		IF=152, IN=153, INCLUDE=154, INCREMENT=155, INDEX=156, INFINITE=157, INIT=158, 
		INNER=159, INSERT=160, INSTEAD=161, INTERSECT=162, INTO=163, IPV4_ADDR=164, 
		IPV6_ADDR=165, IS=166, ISNULL=167, JOIN=168, KERBEROS=169, KEY=170, KEY_PATH=171, 
		KEY_STORE_PROVIDER_NAME=172, KILL=173, LANGUAGE=174, LEFT=175, LIBRARY=176, 
		LIFETIME=177, LIKE=178, RLIKE=179, LLIKE=180, LINENO=181, LINUX=182, LISTENER_IP=183, 
		LISTENER_PORT=184, LOAD=185, LOCAL_SERVICE_NAME=186, LOG=187, MATCHED=188, 
		MASTER=189, MAX_MEMORY=190, MAXTRANSFER=191, MAXVALUE=192, MAX_DISPATCH_LATENCY=193, 
		MAX_EVENT_SIZE=194, MAX_SIZE=195, MAX_OUTSTANDING_IO_PER_VOLUME=196, MEDIADESCRIPTION=197, 
		MEDIANAME=198, MEMBER=199, MEMORY_PARTITION_MODE=200, MERGE=201, MESSAGE_FORWARDING=202, 
		MESSAGE_FORWARD_SIZE=203, MINVALUE=204, MIRROR=205, MUST_CHANGE=206, NATIONAL=207, 
		NEGOTIATE=208, NOCHECK=209, NOFORMAT=210, NOINIT=211, NONCLUSTERED=212, 
		NONE=213, NOREWIND=214, NOSKIP=215, NOUNLOAD=216, NO_CHECKSUM=217, NO_COMPRESSION=218, 
		NO_EVENT_LOSS=219, NOT=220, NOTIFICATION=221, NTLM=222, NULL=223, NULLIF=224, 
		OF=225, OFF=226, OFFSETS=227, OLD_PASSWORD=228, ON=229, ON_FAILURE=230, 
		OPEN=231, OPENDATASOURCE=232, OPENQUERY=233, OPENROWSET=234, OPENXML=235, 
		OPTION=236, OR=237, ORDER=238, OUTER=239, OVER=240, PAGE=241, PARAM_NODE=242, 
		PARTIAL=243, PASSWORD=244, PERCENT=245, PERMISSION_SET=246, PER_CPU=247, 
		PER_DB=248, PER_NODE=249, PIVOT=250, PLAN=251, PLATFORM=252, POLICY=253, 
		PRECISION=254, PREDICATE=255, PRIMARY=256, PRINT=257, PROC=258, PROCEDURE=259, 
		PROCESS=260, PUBLIC=261, PYTHON=262, R=263, RAISERROR=264, RAW=265, READ=266, 
		READTEXT=267, READ_WRITE_FILEGROUPS=268, RECONFIGURE=269, REFERENCES=270, 
		REGENERATE=271, RELATED_CONVERSATION=272, RELATED_CONVERSATION_GROUP=273, 
		REPLICATION=274, REQUIRED=275, RESET=276, RESTART=277, RESTORE=278, RESTRICT=279, 
		RESUME=280, RETAINDAYS=281, RETURN=282, RETURNS=283, REVERT=284, REVOKE=285, 
		REWIND=286, RIGHT=287, ROLLBACK=288, ROLE=289, ROWCOUNT=290, ROWGUIDCOL=291, 
		RSA_512=292, RSA_1024=293, RSA_2048=294, RSA_3072=295, RSA_4096=296, SAFETY=297, 
		RULE=298, SAFE=299, SAVE=300, SCHEDULER=301, SCHEMA=302, SCHEME=303, SECURITY=304, 
		SECURITYAUDIT=305, SELECT=306, SEMANTICKEYPHRASETABLE=307, SEMANTICSIMILARITYDETAILSTABLE=308, 
		SEMANTICSIMILARITYTABLE=309, SEQUENCE=310, SERVER=311, SERVICE=312, SERVICE_BROKER=313, 
		SERVICE_NAME=314, SESSION=315, SESSION_USER=316, SET=317, SETUSER=318, 
		SHUTDOWN=319, SID=320, SKIP_KEYWORD=321, SOFTNUMA=322, SOME=323, SOURCE=324, 
		SPECIFICATION=325, SPLIT=326, SQLDUMPERFLAGS=327, SQLDUMPERPATH=328, SQLDUMPERTIMEOUT=329, 
		STATISTICS=330, STATE=331, STATS=332, START=333, STARTED=334, STARTUP_STATE=335, 
		STOP=336, STOPPED=337, STOP_ON_ERROR=338, SUPPORTED=339, SYSTEM=340, SYSTEM_USER=341, 
		TABLE=342, TABLESAMPLE=343, TAPE=344, TARGET=345, TCP=346, TEXTSIZE=347, 
		THEN=348, TO=349, TOP=350, TRACK_CAUSALITY=351, TRAN=352, TRANSACTION=353, 
		TRANSFER=354, TRIGGER=355, TRUNCATE=356, TSEQUAL=357, UNCHECKED=358, UNION=359, 
		UNIQUE=360, UNLOCK=361, UNPIVOT=362, UNSAFE=363, UPDATE=364, UPDATETEXT=365, 
		URL=366, USE=367, USED=368, USER=369, VALUES=370, VARYING=371, VERBOSELOGGING=372, 
		VIEW=373, VISIBILITY=374, WAITFOR=375, WHEN=376, WHERE=377, WHILE=378, 
		WINDOWS=379, WITH=380, WITHIN=381, WITHOUT=382, WITNESS=383, WRITETEXT=384, 
		ABSOLUTE=385, ACCENT_SENSITIVITY=386, ACTION=387, ACTIVATION=388, ACTIVE=389, 
		ADDRESS=390, AES_128=391, AES_192=392, AES_256=393, AFFINITY=394, AFTER=395, 
		AGGREGATE=396, ALGORITHM=397, ALLOW_ENCRYPTED_VALUE_MODIFICATIONS=398, 
		ALLOW_SNAPSHOT_ISOLATION=399, ALLOWED=400, ANSI_NULL_DEFAULT=401, ANSI_NULLS=402, 
		ANSI_PADDING=403, ANSI_WARNINGS=404, APPLICATION_LOG=405, APPLY=406, ARITHABORT=407, 
		ASSEMBLY=408, AUDIT=409, AUDIT_GUID=410, AUTO=411, AUTO_CLEANUP=412, AUTO_CLOSE=413, 
		AUTO_CREATE_STATISTICS=414, AUTO_SHRINK=415, AUTO_UPDATE_STATISTICS=416, 
		AUTO_UPDATE_STATISTICS_ASYNC=417, AVAILABILITY=418, AVG=419, BACKUP_PRIORITY=420, 
		BEGIN_DIALOG=421, BIGINT=422, BINARY_BASE64=423, BINARY_CHECKSUM=424, 
		BINDING=425, BLOB_STORAGE=426, BROKER=427, BROKER_INSTANCE=428, BULK_LOGGED=429, 
		CALLER=430, CAP_CPU_PERCENT=431, CAST=432, CATALOG=433, CATCH=434, CHANGE_RETENTION=435, 
		CHANGE_TRACKING=436, CHECKSUM=437, CHECKSUM_AGG=438, CLEANUP=439, COLLECTION=440, 
		COLUMN_MASTER_KEY=441, COMMITTED=442, COMPATIBILITY_LEVEL=443, CONCAT=444, 
		CONCAT_NULL_YIELDS_NULL=445, CONTENT=446, CONTROL=447, COOKIE=448, COUNT=449, 
		COUNT_BIG=450, COUNTER=451, CPU=452, CREATE_NEW=453, CREATION_DISPOSITION=454, 
		CREDENTIAL=455, CRYPTOGRAPHIC=456, CURSOR_CLOSE_ON_COMMIT=457, CURSOR_DEFAULT=458, 
		DATE_CORRELATION_OPTIMIZATION=459, DATEADD=460, DATEDIFF=461, DATENAME=462, 
		DATEPART=463, DAYS=464, DB_CHAINING=465, DB_FAILOVER=466, DECRYPTION=467, 
		DEFAULT_DOUBLE_QUOTE=468, DEFAULT_FULLTEXT_LANGUAGE=469, DEFAULT_LANGUAGE=470, 
		DELAY=471, DELAYED_DURABILITY=472, DELETED=473, DENSE_RANK=474, DEPENDENTS=475, 
		DES=476, DESCRIPTION=477, DESX=478, DHCP=479, DIALOG=480, DIRECTORY_NAME=481, 
		DISABLE=482, DISABLE_BROKER=483, DISABLED=484, DISK_DRIVE=485, DOCUMENT=486, 
		DYNAMIC=487, ELEMENTS=488, EMERGENCY=489, EMPTY=490, ENABLE=491, ENABLE_BROKER=492, 
		ENCRYPTED_VALUE=493, ENCRYPTION=494, ENDPOINT_URL=495, ERROR_BROKER_CONVERSATIONS=496, 
		EXCLUSIVE=497, EXECUTABLE=498, EXIST=499, EXPAND=500, EXPIRY_DATE=501, 
		EXPLICIT=502, FAIL_OPERATION=503, FAILOVER_MODE=504, FAILURE=505, FAILURE_CONDITION_LEVEL=506, 
		FAST=507, FAST_FORWARD=508, FILEGROUP=509, FILEGROWTH=510, FILEPATH=511, 
		FILESTREAM=512, FILTER=513, FIRST=514, FIRST_VALUE=515, FOLLOWING=516, 
		FORCE=517, FORCE_FAILOVER_ALLOW_DATA_LOSS=518, FORCED=519, FORMAT=520, 
		FORWARD_ONLY=521, FULLSCAN=522, FULLTEXT=523, GB=524, GETDATE=525, GETUTCDATE=526, 
		GLOBAL=527, GO=528, GROUP_MAX_REQUESTS=529, GROUPING=530, GROUPING_ID=531, 
		HADR=532, HASH=533, HEALTH_CHECK_TIMEOUT=534, HIGH=535, HONOR_BROKER_PRIORITY=536, 
		HOURS=537, IDENTITY_VALUE=538, IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX=539, 
		IMMEDIATE=540, IMPERSONATE=541, IMPORTANCE=542, INCLUDE_NULL_VALUES=543, 
		INCREMENTAL=544, INITIATOR=545, INPUT=546, INSENSITIVE=547, INSERTED=548, 
		INT=549, IP=550, ISOLATION=551, JSON=552, KB=553, KEEP=554, KEEPFIXED=555, 
		KEY_SOURCE=556, KEYS=557, KEYSET=558, LAG=559, LAST=560, LAST_VALUE=561, 
		LEAD=562, LEVEL=563, LIST=564, LISTENER=565, LISTENER_URL=566, LOB_COMPACTION=567, 
		LOCAL=568, LOCATION=569, LOCK=570, LOCK_ESCALATION=571, LOGIN=572, LOOP=573, 
		LOW=574, MANUAL=575, MARK=576, MATERIALIZED=577, MAX=578, MAX_CPU_PERCENT=579, 
		MAX_DOP=580, MAX_FILES=581, MAX_IOPS_PER_VOLUME=582, MAX_MEMORY_PERCENT=583, 
		MAX_PROCESSES=584, MAX_QUEUE_READERS=585, MAX_ROLLOVER_FILES=586, MAXDOP=587, 
		MAXRECURSION=588, MAXSIZE=589, MB=590, MEDIUM=591, MEMORY_OPTIMIZED_DATA=592, 
		MESSAGE=593, MIN=594, MIN_ACTIVE_ROWVERSION=595, MIN_CPU_PERCENT=596, 
		MIN_IOPS_PER_VOLUME=597, MIN_MEMORY_PERCENT=598, MINUTES=599, MIRROR_ADDRESS=600, 
		MIXED_PAGE_ALLOCATION=601, MODE=602, MODIFY=603, MOVE=604, MULTI_USER=605, 
		NAME=606, NESTED_TRIGGERS=607, NEW_ACCOUNT=608, NEW_BROKER=609, NEW_PASSWORD=610, 
		NEXT=611, NO=612, NO_TRUNCATE=613, NO_WAIT=614, NOCOUNT=615, NODES=616, 
		NOEXPAND=617, NON_TRANSACTED_ACCESS=618, NORECOMPUTE=619, NORECOVERY=620, 
		NOWAIT=621, NTILE=622, NUMANODE=623, NUMBER=624, NUMERIC_ROUNDABORT=625, 
		OBJECT=626, OFFLINE=627, OFFSET=628, OLD_ACCOUNT=629, ONLINE=630, ONLY=631, 
		OPEN_EXISTING=632, OPTIMISTIC=633, OPTIMIZE=634, OUT=635, OUTPUT=636, 
		OWNER=637, PAGE_VERIFY=638, PARAMETERIZATION=639, PARTITION=640, PARTITIONS=641, 
		PARTNER=642, PATH=643, POISON_MESSAGE_HANDLING=644, POOL=645, PORT=646, 
		PRECEDING=647, PRIMARY_ROLE=648, PRIOR=649, PRIORITY=650, PRIORITY_LEVEL=651, 
		PRIVATE=652, PRIVATE_KEY=653, PRIVILEGES=654, PROCEDURE_NAME=655, PROPERTY=656, 
		PROVIDER=657, PROVIDER_KEY_NAME=658, QUERY=659, QUEUE=660, QUEUE_DELAY=661, 
		QUOTED_IDENTIFIER=662, RANGE=663, RANK=664, RC2=665, RC4=666, RC4_128=667, 
		READ_COMMITTED_SNAPSHOT=668, READ_ONLY=669, READ_ONLY_ROUTING_LIST=670, 
		READ_WRITE=671, READONLY=672, REBUILD=673, RECEIVE=674, RECOMPILE=675, 
		RECOVERY=676, RECURSIVE_TRIGGERS=677, RELATIVE=678, REMOTE=679, REMOTE_SERVICE_NAME=680, 
		REMOVE=681, REORGANIZE=682, REPEATABLE=683, REPLICA=684, REQUEST_MAX_CPU_TIME_SEC=685, 
		REQUEST_MAX_MEMORY_GRANT_PERCENT=686, REQUEST_MEMORY_GRANT_TIMEOUT_SEC=687, 
		REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT=688, RESERVE_DISK_SPACE=689, 
		RESOURCE=690, RESOURCE_MANAGER_LOCATION=691, RESTRICTED_USER=692, RETENTION=693, 
		ROBUST=694, ROOT=695, ROUTE=696, ROW=697, ROW_NUMBER=698, ROWGUID=699, 
		ROWS=700, SAMPLE=701, SCHEMABINDING=702, SCOPED=703, SCROLL=704, SCROLL_LOCKS=705, 
		SEARCH=706, SECONDARY=707, SECONDARY_ONLY=708, SECONDARY_ROLE=709, SECONDS=710, 
		SECRET=711, SECURITY_LOG=712, SEEDING_MODE=713, SELF=714, SEMI_SENSITIVE=715, 
		SEND=716, SENT=717, SERIALIZABLE=718, SESSION_TIMEOUT=719, SETERROR=720, 
		SHARE=721, SHOWPLAN=722, SIGNATURE=723, SIMPLE=724, SINGLE_USER=725, SIZE=726, 
		SMALLINT=727, SNAPSHOT=728, SPATIAL_WINDOW_MAX_CELLS=729, STANDBY=730, 
		START_DATE=731, STATIC=732, STATS_STREAM=733, STATUS=734, STDEV=735, STDEVP=736, 
		STOPLIST=737, STUFF=738, SUBJECT=739, SUM=740, SUSPEND=741, SYMMETRIC=742, 
		SYNCHRONOUS_COMMIT=743, SYNONYM=744, TAKE=745, TARGET_RECOVERY_TIME=746, 
		TB=747, TEXTIMAGE_ON=748, THROW=749, TIES=750, TIME=751, TIMEOUT=752, 
		TIMER=753, TINYINT=754, TORN_PAGE_DETECTION=755, TRANSFORM_NOISE_WORDS=756, 
		TRIPLE_DES=757, TRIPLE_DES_3KEY=758, TRUSTWORTHY=759, TRY=760, TSQL=761, 
		TWO_DIGIT_YEAR_CUTOFF=762, TYPE=763, TYPE_WARNING=764, UNBOUNDED=765, 
		UNCOMMITTED=766, UNKNOWN=767, UNLIMITED=768, USING=769, VALID_XML=770, 
		VALIDATION=771, VALUE=772, VAR=773, VARP=774, VIEW_METADATA=775, VIEWS=776, 
		WAIT=777, WELL_FORMED_XML=778, WITHOUT_ARRAY_WRAPPER=779, WORK=780, WORKLOAD=781, 
		XML=782, XMLDATA=783, XMLNAMESPACES=784, XMLSCHEMA=785, XSINIL=786, DOLLAR_ACTION=787, 
		SPACE=788, COMMENT=789, LINE_COMMENT=790, DOUBLE_QUOTE_ID=791, SINGLE_QUOTE=792, 
		SQUARE_BRACKET_ID=793, LOCAL_ID=794, DECIMAL=795, ID=796, QUOTED_URL=797, 
		QUOTED_HOST_AND_PORT=798, STRING=799, BINARY=800, FLOAT=801, REAL=802, 
		EQUAL=803, GREATER=804, LESS=805, EXCLAMATION=806, PLUS_ASSIGN=807, MINUS_ASSIGN=808, 
		MULT_ASSIGN=809, DIV_ASSIGN=810, MOD_ASSIGN=811, AND_ASSIGN=812, XOR_ASSIGN=813, 
		OR_ASSIGN=814, DOUBLE_BAR=815, DOT=816, UNDERLINE=817, AT=818, SHARP=819, 
		DOLLAR=820, LR_BRACKET=821, RR_BRACKET=822, COMMA=823, SEMI=824, COLON=825, 
		STAR=826, DIVIDE=827, MODULE=828, PLUS=829, MINUS=830, BIT_NOT=831, BIT_OR=832, 
		BIT_AND=833, BIT_XOR=834, IPV4_OCTECT=835;
	public static final int
		RULE_search_condition = 0, RULE_search_condition_and = 1, RULE_search_condition_not = 2, 
		RULE_predicate = 3, RULE_expression_list = 4, RULE_expression = 5, RULE_function_call = 6, 
		RULE_aggregate_windowed_function = 7, RULE_func_proc_name = 8, RULE_full_column_name = 9, 
		RULE_table_name = 10, RULE_unary_operator_expression = 11, RULE_bracket_expression = 12, 
		RULE_constant_expression = 13, RULE_comparison_operator = 14, RULE_assignment_operator = 15, 
		RULE_null_notnull = 16, RULE_constant = 17, RULE_sign = 18, RULE_id = 19;
	public static final String[] ruleNames = {
		"search_condition", "search_condition_and", "search_condition_not", "predicate", 
		"expression_list", "expression", "function_call", "aggregate_windowed_function", 
		"func_proc_name", "full_column_name", "table_name", "unary_operator_expression", 
		"bracket_expression", "constant_expression", "comparison_operator", "assignment_operator", 
		"null_notnull", "constant", "sign", "id"
	};

	private static final String[] _LITERAL_NAMES = {
		null, "'ABSENT'", "'ADD'", "'AES'", "'ALL'", "'ALLOW_CONNECTIONS'", "'ALLOW_MULTIPLE_EVENT_LOSS'", 
		"'ALLOW_SINGLE_EVENT_LOSS'", "'ALTER'", null, "'ANONYMOUS'", "'ANY'", 
		"'APPEND'", "'APPLICATION'", null, null, "'ASYMMETRIC'", "'ASYNCHRONOUS_COMMIT'", 
		"'AUTHORIZATION'", "'AUTHENTICATION'", "'AUTOMATED_BACKUP_PREFERENCE'", 
		"'AUTOMATIC'", "'AVAILABILITY_MODE'", "'\\'", "'BACKUP'", "'BEFORE'", 
		"'BEGIN'", "'BETWEEN'", "'BLOCK'", "'BLOCKSIZE'", "'BLOCKING_HIERARCHY'", 
		"'BREAK'", "'BROWSE'", "'BUFFER'", "'BUFFERCOUNT'", "'BULK'", null, "'CACHE'", 
		"'CALLED'", "'CASCADE'", "'CASE'", "'CERTIFICATE'", "'CHANGETABLE'", "'CHANGES'", 
		"'CHECK'", "'CHECKPOINT'", "'CHECK_POLICY'", "'CHECK_EXPIRATION'", "'CLASSIFIER_FUNCTION'", 
		"'CLOSE'", "'CLUSTER'", "'CLUSTERED'", "'COALESCE'", "'COLLATE'", "'COLUMN'", 
		"'COMPRESSION'", "'COMMIT'", "'COMPUTE'", "'CONFIGURATION'", "'CONSTRAINT'", 
		"'CONTAINMENT'", "'CONTAINS'", "'CONTAINSTABLE'", "'CONTEXT'", "'CONTINUE'", 
		"'CONTINUE_AFTER_ERROR'", "'CONTRACT'", "'CONTRACT_NAME'", "'CONVERSATION'", 
		null, "'COPY_ONLY'", "'CREATE'", "'CROSS'", "'CURRENT'", "'CURRENT_DATE'", 
		"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'CURSOR'", 
		"'CYCLE'", "'DATA'", "'DATA_COMPRESSION'", "'DATA_SOURCE'", "'DATABASE'", 
		"'DATABASE_MIRRORING'", "'DBCC'", "'DEALLOCATE'", "'DECLARE'", "'DEFAULT'", 
		"'DEFAULT_DATABASE'", "'DEFAULT_SCHEMA'", "'DELETE'", "'DENY'", "'DESC'", 
		"'DIAGNOSTICS'", "'DIFFERENTIAL'", "'DISK'", "'DISTINCT'", "'DISTRIBUTED'", 
		"'DOUBLE'", "'\\\\'", "'//'", "'DROP'", "'DTC_SUPPORT'", "'DUMP'", "'ELSE'", 
		"'ENABLED'", "'END'", "'ENDPOINT'", "'ERRLVL'", "'ESCAPE'", "'ERROR'", 
		"'EVENT'", null, "'EVENT_RETENTION_MODE'", "'EXCEPT'", "'EXECUTABLE_FILE'", 
		null, "'EXISTS'", "'EXPIREDATE'", "'EXIT'", "'EXTENSION'", "'EXTERNAL'", 
		"'EXTERNAL_ACCESS'", "'FAILOVER'", "'FAILURECONDITIONLEVEL'", "'FAN_IN'", 
		"'FETCH'", "'FILE'", "'FILENAME'", "'FILLFACTOR'", "'FILE_SNAPSHOT'", 
		"'FOR'", "'FORCESEEK'", "'FORCE_SERVICE_ALLOW_DATA_LOSS'", "'FOREIGN'", 
		"'FREETEXT'", "'FREETEXTTABLE'", "'FROM'", "'FULL'", "'FUNCTION'", "'GET'", 
		"'GOTO'", "'GOVERNOR'", "'GRANT'", "'GROUP'", "'HAVING'", "'HASHED'", 
		"'HEALTHCHECKTIMEOUT'", "'IDENTITY'", "'IDENTITYCOL'", "'IDENTITY_INSERT'", 
		"'IF'", null, "'INCLUDE'", "'INCREMENT'", "'INDEX'", "'INFINITE'", "'INIT'", 
		"'INNER'", "'INSERT'", "'INSTEAD'", "'INTERSECT'", "'INTO'", null, null, 
		null, null, "'JOIN'", "'KERBEROS'", "'KEY'", "'KEY_PATH'", "'KEY_STORE_PROVIDER_NAME'", 
		"'KILL'", "'LANGUAGE'", "'LEFT'", "'LIBRARY'", "'LIFETIME'", null, null, 
		null, "'LINENO'", "'LINUX'", "'LISTENER_IP'", "'LISTENER_PORT'", "'LOAD'", 
		"'LOCAL_SERVICE_NAME'", "'LOG'", "'MATCHED'", "'MASTER'", "'MAX_MEMORY'", 
		"'MAXTRANSFER'", "'MAXVALUE'", "'MAX_DISPATCH_LATENCY'", "'MAX_EVENT_SIZE'", 
		"'MAX_SIZE'", "'MAX_OUTSTANDING_IO_PER_VOLUME'", "'MEDIADESCRIPTION'", 
		"'MEDIANAME'", "'MEMBER'", "'MEMORY_PARTITION_MODE'", "'MERGE'", "'MESSAGE_FORWARDING'", 
		"'MESSAGE_FORWARD_SIZE'", "'MINVALUE'", "'MIRROR'", "'MUST_CHANGE'", "'NATIONAL'", 
		"'NEGOTIATE'", "'NOCHECK'", "'NOFORMAT'", "'NOINIT'", "'NONCLUSTERED'", 
		"'NONE'", "'NOREWIND'", "'NOSKIP'", "'NOUNLOAD'", "'NO_CHECKSUM'", "'NO_COMPRESSION'", 
		"'NO_EVENT_LOSS'", null, "'NOTIFICATION'", "'NTLM'", null, "'NULLIF'", 
		"'OF'", "'OFF'", "'OFFSETS'", "'OLD_PASSWORD'", null, "'ON_FAILURE'", 
		"'OPEN'", "'OPENDATASOURCE'", "'OPENQUERY'", "'OPENROWSET'", "'OPENXML'", 
		"'OPTION'", null, null, null, "'OVER'", "'PAGE'", "'PARAM_NODE'", "'PARTIAL'", 
		"'PASSWORD'", "'PERCENT'", "'PERMISSION_SET'", "'PER_CPU'", "'PER_DB'", 
		"'PER_NODE'", "'PIVOT'", "'PLAN'", "'PLATFORM'", "'POLICY'", "'PRECISION'", 
		"'PREDICATE'", "'PRIMARY'", "'PRINT'", "'PROC'", "'PROCEDURE'", "'PROCESS'", 
		"'PUBLIC'", "'PYTHON'", "'R'", "'RAISERROR'", "'RAW'", "'READ'", "'READTEXT'", 
		"'READ_WRITE_FILEGROUPS'", "'RECONFIGURE'", "'REFERENCES'", "'REGENERATE'", 
		"'RELATED_CONVERSATION'", "'RELATED_CONVERSATION_GROUP'", "'REPLICATION'", 
		"'REQUIRED'", "'RESET'", "'RESTART'", "'RESTORE'", "'RESTRICT'", "'RESUME'", 
		"'RETAINDAYS'", "'RETURN'", "'RETURNS'", "'REVERT'", "'REVOKE'", "'REWIND'", 
		"'RIGHT'", "'ROLLBACK'", "'ROLE'", "'ROWCOUNT'", "'ROWGUIDCOL'", "'RSA_512'", 
		"'RSA_1024'", "'RSA_2048'", "'RSA_3072'", "'RSA_4096'", "'SAFETY'", "'RULE'", 
		"'SAFE'", "'SAVE'", "'SCHEDULER'", "'SCHEMA'", "'SCHEME'", "'SECURITY'", 
		"'SECURITYAUDIT'", "'SELECT'", "'SEMANTICKEYPHRASETABLE'", "'SEMANTICSIMILARITYDETAILSTABLE'", 
		"'SEMANTICSIMILARITYTABLE'", "'SEQUENCE'", "'SERVER'", "'SERVICE'", "'SERVICE_BROKER'", 
		"'SERVICE_NAME'", "'SESSION'", "'SESSION_USER'", "'SET'", "'SETUSER'", 
		"'SHUTDOWN'", "'SID'", "'SKIP'", "'SOFTNUMA'", "'SOME'", "'SOURCE'", "'SPECIFICATION'", 
		"'SPLIT'", "'SQLDUMPERFLAGS'", "'SQLDUMPERPATH'", "'SQLDUMPERTIMEOUTS'", 
		"'STATISTICS'", "'STATE'", "'STATS'", "'START'", "'STARTED'", "'STARTUP_STATE'", 
		"'STOP'", "'STOPPED'", "'STOP_ON_ERROR'", "'SUPPORTED'", "'SYSTEM'", "'SYSTEM_USER'", 
		"'TABLE'", "'TABLESAMPLE'", "'TAPE'", "'TARGET'", "'TCP'", "'TEXTSIZE'", 
		"'THEN'", "'TO'", null, "'TRACK_CAUSALITY'", "'TRAN'", "'TRANSACTION'", 
		"'TRANSFER'", "'TRIGGER'", "'TRUNCATE'", "'TSEQUAL'", "'UNCHECKED'", "'UNION'", 
		"'UNIQUE'", "'UNLOCK'", "'UNPIVOT'", "'UNSAFE'", "'UPDATE'", "'UPDATETEXT'", 
		"'URL'", "'USE'", "'USED'", "'USER'", "'VALUES'", "'VARYING'", "'VERBOSELOGGING'", 
		"'VIEW'", "'VISIBILITY'", "'WAITFOR'", "'WHEN'", "'WHERE'", "'WHILE'", 
		"'WINDOWS'", "'WITH'", "'WITHIN'", "'WITHOUT'", "'WITNESS'", "'WRITETEXT'", 
		"'ABSOLUTE'", "'ACCENT_SENSITIVITY'", "'ACTION'", "'ACTIVATION'", "'ACTIVE'", 
		"'ADDRESS'", "'AES_128'", "'AES_192'", "'AES_256'", "'AFFINITY'", "'AFTER'", 
		"'AGGREGATE'", "'ALGORITHM'", "'ALLOW_ENCRYPTED_VALUE_MODIFICATIONS'", 
		"'ALLOW_SNAPSHOT_ISOLATION'", "'ALLOWED'", "'ANSI_NULL_DEFAULT'", "'ANSI_NULLS'", 
		"'ANSI_PADDING'", "'ANSI_WARNINGS'", "'APPLICATION_LOG'", "'APPLY'", "'ARITHABORT'", 
		"'ASSEMBLY'", "'AUDIT'", "'AUDIT_GUID'", "'AUTO'", "'AUTO_CLEANUP'", "'AUTO_CLOSE'", 
		"'AUTO_CREATE_STATISTICS'", "'AUTO_SHRINK'", "'AUTO_UPDATE_STATISTICS'", 
		"'AUTO_UPDATE_STATISTICS_ASYNC'", "'AVAILABILITY'", "'AVG'", "'BACKUP_PRIORITY'", 
		"'BEGIN_DIALOG'", "'BIGINT'", "'BINARY BASE64'", "'BINARY_CHECKSUM'", 
		"'BINDING'", "'BLOB_STORAGE'", "'BROKER'", "'BROKER_INSTANCE'", "'BULK_LOGGED'", 
		"'CALLER'", "'CAP_CPU_PERCENT'", null, "'CATALOG'", "'CATCH'", "'CHANGE_RETENTION'", 
		"'CHANGE_TRACKING'", "'CHECKSUM'", "'CHECKSUM_AGG'", "'CLEANUP'", "'COLLECTION'", 
		"'COLUMN_MASTER_KEY'", "'COMMITTED'", "'COMPATIBILITY_LEVEL'", "'CONCAT'", 
		"'CONCAT_NULL_YIELDS_NULL'", "'CONTENT'", "'CONTROL'", "'COOKIE'", null, 
		"'COUNT_BIG'", "'COUNTER'", "'CPU'", "'CREATE_NEW'", "'CREATION_DISPOSITION'", 
		"'CREDENTIAL'", "'CRYPTOGRAPHIC'", "'CURSOR_CLOSE_ON_COMMIT'", "'CURSOR_DEFAULT'", 
		"'DATE_CORRELATION_OPTIMIZATION'", "'DATEADD'", "'DATEDIFF'", "'DATENAME'", 
		"'DATEPART'", "'DAYS'", "'DB_CHAINING'", "'DB_FAILOVER'", "'DECRYPTION'", 
		null, "'DEFAULT_FULLTEXT_LANGUAGE'", "'DEFAULT_LANGUAGE'", "'DELAY'", 
		"'DELAYED_DURABILITY'", "'DELETED'", "'DENSE_RANK'", "'DEPENDENTS'", "'DES'", 
		"'DESCRIPTION'", "'DESX'", "'DHCP'", "'DIALOG'", "'DIRECTORY_NAME'", "'DISABLE'", 
		"'DISABLE_BROKER'", "'DISABLED'", null, "'DOCUMENT'", "'DYNAMIC'", "'ELEMENTS'", 
		"'EMERGENCY'", "'EMPTY'", "'ENABLE'", "'ENABLE_BROKER'", "'ENCRYPTED_VALUE'", 
		"'ENCRYPTION'", "'ENDPOINT_URL'", "'ERROR_BROKER_CONVERSATIONS'", "'EXCLUSIVE'", 
		"'EXECUTABLE'", "'EXIST'", "'EXPAND'", "'EXPIRY_DATE'", "'EXPLICIT'", 
		"'FAIL_OPERATION'", "'FAILOVER_MODE'", "'FAILURE'", "'FAILURE_CONDITION_LEVEL'", 
		"'FAST'", "'FAST_FORWARD'", "'FILEGROUP'", "'FILEGROWTH'", "'FILEPATH'", 
		"'FILESTREAM'", "'FILTER'", null, "'FIRST_VALUE'", "'FOLLOWING'", "'FORCE'", 
		"'FORCE_FAILOVER_ALLOW_DATA_LOSS'", "'FORCED'", "'FORMAT'", "'FORWARD_ONLY'", 
		"'FULLSCAN'", "'FULLTEXT'", "'GB'", "'GETDATE'", "'GETUTCDATE'", "'GLOBAL'", 
		"'GO'", "'GROUP_MAX_REQUESTS'", "'GROUPING'", "'GROUPING_ID'", "'HADR'", 
		"'HASH'", "'HEALTH_CHECK_TIMEOUT'", "'HIGH'", "'HONOR_BROKER_PRIORITY'", 
		"'HOURS'", "'IDENTITY_VALUE'", "'IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX'", 
		"'IMMEDIATE'", "'IMPERSONATE'", "'IMPORTANCE'", "'INCLUDE_NULL_VALUES'", 
		"'INCREMENTAL'", "'INITIATOR'", "'INPUT'", "'INSENSITIVE'", "'INSERTED'", 
		"'INT'", "'IP'", "'ISOLATION'", "'JSON'", "'KB'", "'KEEP'", "'KEEPFIXED'", 
		"'KEY_SOURCE'", "'KEYS'", "'KEYSET'", "'LAG'", "'LAST'", "'LAST_VALUE'", 
		"'LEAD'", "'LEVEL'", "'LIST'", "'LISTENER'", "'LISTENER_URL'", "'LOB_COMPACTION'", 
		"'LOCAL'", "'LOCATION'", "'LOCK'", "'LOCK_ESCALATION'", "'LOGIN'", "'LOOP'", 
		"'LOW'", "'MANUAL'", "'MARK'", "'MATERIALIZED'", null, "'MAX_CPU_PERCENT'", 
		"'MAX_DOP'", "'MAX_FILES'", "'MAX_IOPS_PER_VOLUME'", "'MAX_MEMORY_PERCENT'", 
		"'MAX_PROCESSES'", "'MAX_QUEUE_READERS'", "'MAX_ROLLOVER_FILES'", "'MAXDOP'", 
		"'MAXRECURSION'", "'MAXSIZE'", "'MB'", "'MEDIUM'", "'MEMORY_OPTIMIZED_DATA'", 
		"'MESSAGE'", null, "'MIN_ACTIVE_ROWVERSION'", "'MIN_CPU_PERCENT'", "'MIN_IOPS_PER_VOLUME'", 
		"'MIN_MEMORY_PERCENT'", "'MINUTES'", "'MIRROR_ADDRESS'", "'MIXED_PAGE_ALLOCATION'", 
		"'MODE'", "'MODIFY'", "'MOVE'", "'MULTI_USER'", "'NAME'", "'NESTED_TRIGGERS'", 
		"'NEW_ACCOUNT'", "'NEW_BROKER'", "'NEW_PASSWORD'", "'NEXT'", "'NO'", "'NO_TRUNCATE'", 
		"'NO_WAIT'", "'NOCOUNT'", "'NODES'", "'NOEXPAND'", "'NON_TRANSACTED_ACCESS'", 
		"'NORECOMPUTE'", "'NORECOVERY'", "'NOWAIT'", "'NTILE'", "'NUMANODE'", 
		"'NUMBER'", "'NUMERIC_ROUNDABORT'", "'OBJECT'", "'OFFLINE'", "'OFFSET'", 
		"'OLD_ACCOUNT'", "'ONLINE'", "'ONLY'", "'OPEN_EXISTING'", "'OPTIMISTIC'", 
		"'OPTIMIZE'", "'OUT'", "'OUTPUT'", "'OWNER'", "'PAGE_VERIFY'", "'PARAMETERIZATION'", 
		"'PARTITION'", "'PARTITIONS'", "'PARTNER'", "'PATH'", "'POISON_MESSAGE_HANDLING'", 
		"'POOL'", "'PORT'", "'PRECEDING'", "'PRIMARY_ROLE'", "'PRIOR'", "'PRIORITY'", 
		"'PRIORITY_LEVEL'", "'PRIVATE'", "'PRIVATE_KEY'", "'PRIVILEGES'", "'PROCEDURE_NAME'", 
		"'PROPERTY'", "'PROVIDER'", "'PROVIDER_KEY_NAME'", "'QUERY'", "'QUEUE'", 
		"'QUEUE_DELAY'", "'QUOTED_IDENTIFIER'", "'RANGE'", "'RANK'", "'RC2'", 
		"'RC4'", "'RC4_128'", "'READ_COMMITTED_SNAPSHOT'", "'READ_ONLY'", "'READ_ONLY_ROUTING_LIST'", 
		"'READ_WRITE'", "'READONLY'", "'REBUILD'", "'RECEIVE'", "'RECOMPILE'", 
		"'RECOVERY'", "'RECURSIVE_TRIGGERS'", "'RELATIVE'", "'REMOTE'", "'REMOTE_SERVICE_NAME'", 
		"'REMOVE'", "'REORGANIZE'", "'REPEATABLE'", "'REPLICA'", "'REQUEST_MAX_CPU_TIME_SEC'", 
		"'REQUEST_MAX_MEMORY_GRANT_PERCENT'", "'REQUEST_MEMORY_GRANT_TIMEOUT_SEC'", 
		"'REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT'", "'RESERVE_DISK_SPACE'", 
		"'RESOURCE'", "'RESOURCE_MANAGER_LOCATION'", "'RESTRICTED_USER'", "'RETENTION'", 
		"'ROBUST'", "'ROOT'", "'ROUTE'", "'ROW'", "'ROW_NUMBER'", "'ROWGUID'", 
		"'ROWS'", "'SAMPLE'", "'SCHEMABINDING'", "'SCOPED'", "'SCROLL'", "'SCROLL_LOCKS'", 
		"'SEARCH'", "'SECONDARY'", "'SECONDARY_ONLY'", "'SECONDARY_ROLE'", "'SECONDS'", 
		"'SECRET'", "'SECURITY_LOG'", "'SEEDING_MODE'", "'SELF'", "'SEMI_SENSITIVE'", 
		"'SEND'", "'SENT'", "'SERIALIZABLE'", "'SESSION_TIMEOUT'", "'SETERROR'", 
		"'SHARE'", "'SHOWPLAN'", "'SIGNATURE'", "'SIMPLE'", "'SINGLE_USER'", "'SIZE'", 
		"'SMALLINT'", "'SNAPSHOT'", "'SPATIAL_WINDOW_MAX_CELLS'", "'STANDBY'", 
		"'START_DATE'", "'STATIC'", "'STATS_STREAM'", "'STATUS'", "'STDEV'", "'STDEVP'", 
		"'STOPLIST'", "'STUFF'", "'SUBJECT'", "'SUM'", "'SUSPEND'", "'SYMMETRIC'", 
		"'SYNCHRONOUS_COMMIT'", "'SYNONYM'", "'TAKE'", "'TARGET_RECOVERY_TIME'", 
		"'TB'", "'TEXTIMAGE_ON'", "'THROW'", "'TIES'", "'TIME'", "'TIMEOUT'", 
		"'TIMER'", "'TINYINT'", "'TORN_PAGE_DETECTION'", "'TRANSFORM_NOISE_WORDS'", 
		"'TRIPLE_DES'", "'TRIPLE_DES_3KEY'", "'TRUSTWORTHY'", "'TRY'", "'TSQL'", 
		"'TWO_DIGIT_YEAR_CUTOFF'", "'TYPE'", "'TYPE_WARNING'", "'UNBOUNDED'", 
		"'UNCOMMITTED'", "'UNKNOWN'", "'UNLIMITED'", "'USING'", "'VALID_XML'", 
		"'VALIDATION'", "'VALUE'", "'VAR'", "'VARP'", "'VIEW_METADATA'", "'VIEWS'", 
		"'WAIT'", "'WELL_FORMED_XML'", "'WITHOUT_ARRAY_WRAPPER'", "'WORK'", "'WORKLOAD'", 
		"'XML'", "'XMLDATA'", "'XMLNAMESPACES'", "'XMLSCHEMA'", "'XSINIL'", "'$ACTION'", 
		null, null, null, null, "'''", null, null, null, null, null, null, null, 
		null, null, null, "'='", "'>'", "'<'", "'!'", "'+='", "'-='", "'*='", 
		"'/='", "'%='", "'&='", "'^='", "'|='", "'||'", "'.'", "'_'", "'@'", "'#'", 
		"'$'", "'('", "')'", "','", "';'", "':'", "'*'", "'/'", "'%'", "'+'", 
		"'-'", "'~'", "'|'", "'&'", "'^'"
	};
	private static final String[] _SYMBOLIC_NAMES = {
		null, "ABSENT", "ADD", "AES", "ALL", "ALLOW_CONNECTIONS", "ALLOW_MULTIPLE_EVENT_LOSS", 
		"ALLOW_SINGLE_EVENT_LOSS", "ALTER", "AND", "ANONYMOUS", "ANY", "APPEND", 
		"APPLICATION", "AS", "ASC", "ASYMMETRIC", "ASYNCHRONOUS_COMMIT", "AUTHORIZATION", 
		"AUTHENTICATION", "AUTOMATED_BACKUP_PREFERENCE", "AUTOMATIC", "AVAILABILITY_MODE", 
		"BACKSLASH", "BACKUP", "BEFORE", "BEGIN", "BETWEEN", "BLOCK", "BLOCKSIZE", 
		"BLOCKING_HIERARCHY", "BREAK", "BROWSE", "BUFFER", "BUFFERCOUNT", "BULK", 
		"BY", "CACHE", "CALLED", "CASCADE", "CASE", "CERTIFICATE", "CHANGETABLE", 
		"CHANGES", "CHECK", "CHECKPOINT", "CHECK_POLICY", "CHECK_EXPIRATION", 
		"CLASSIFIER_FUNCTION", "CLOSE", "CLUSTER", "CLUSTERED", "COALESCE", "COLLATE", 
		"COLUMN", "COMPRESSION", "COMMIT", "COMPUTE", "CONFIGURATION", "CONSTRAINT", 
		"CONTAINMENT", "CONTAINS", "CONTAINSTABLE", "CONTEXT", "CONTINUE", "CONTINUE_AFTER_ERROR", 
		"CONTRACT", "CONTRACT_NAME", "CONVERSATION", "CONVERT", "COPY_ONLY", "CREATE", 
		"CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
		"CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATA_COMPRESSION", "DATA_SOURCE", 
		"DATABASE", "DATABASE_MIRRORING", "DBCC", "DEALLOCATE", "DECLARE", "DEFAULT", 
		"DEFAULT_DATABASE", "DEFAULT_SCHEMA", "DELETE", "DENY", "DESC", "DIAGNOSTICS", 
		"DIFFERENTIAL", "DISK", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DOUBLE_BACK_SLASH", 
		"DOUBLE_FORWARD_SLASH", "DROP", "DTC_SUPPORT", "DUMP", "ELSE", "ENABLED", 
		"END", "ENDPOINT", "ERRLVL", "ESCAPE", "ERROR", "EVENT", "EVENTDATA", 
		"EVENT_RETENTION_MODE", "EXCEPT", "EXECUTABLE_FILE", "EXECUTE", "EXISTS", 
		"EXPIREDATE", "EXIT", "EXTENSION", "EXTERNAL", "EXTERNAL_ACCESS", "FAILOVER", 
		"FAILURECONDITIONLEVEL", "FAN_IN", "FETCH", "FILE", "FILENAME", "FILLFACTOR", 
		"FILE_SNAPSHOT", "FOR", "FORCESEEK", "FORCE_SERVICE_ALLOW_DATA_LOSS", 
		"FOREIGN", "FREETEXT", "FREETEXTTABLE", "FROM", "FULL", "FUNCTION", "GET", 
		"GOTO", "GOVERNOR", "GRANT", "GROUP", "HAVING", "HASHED", "HEALTHCHECKTIMEOUT", 
		"IDENTITY", "IDENTITYCOL", "IDENTITY_INSERT", "IF", "IN", "INCLUDE", "INCREMENT", 
		"INDEX", "INFINITE", "INIT", "INNER", "INSERT", "INSTEAD", "INTERSECT", 
		"INTO", "IPV4_ADDR", "IPV6_ADDR", "IS", "ISNULL", "JOIN", "KERBEROS", 
		"KEY", "KEY_PATH", "KEY_STORE_PROVIDER_NAME", "KILL", "LANGUAGE", "LEFT", 
		"LIBRARY", "LIFETIME", "LIKE", "RLIKE", "LLIKE", "LINENO", "LINUX", "LISTENER_IP", 
		"LISTENER_PORT", "LOAD", "LOCAL_SERVICE_NAME", "LOG", "MATCHED", "MASTER", 
		"MAX_MEMORY", "MAXTRANSFER", "MAXVALUE", "MAX_DISPATCH_LATENCY", "MAX_EVENT_SIZE", 
		"MAX_SIZE", "MAX_OUTSTANDING_IO_PER_VOLUME", "MEDIADESCRIPTION", "MEDIANAME", 
		"MEMBER", "MEMORY_PARTITION_MODE", "MERGE", "MESSAGE_FORWARDING", "MESSAGE_FORWARD_SIZE", 
		"MINVALUE", "MIRROR", "MUST_CHANGE", "NATIONAL", "NEGOTIATE", "NOCHECK", 
		"NOFORMAT", "NOINIT", "NONCLUSTERED", "NONE", "NOREWIND", "NOSKIP", "NOUNLOAD", 
		"NO_CHECKSUM", "NO_COMPRESSION", "NO_EVENT_LOSS", "NOT", "NOTIFICATION", 
		"NTLM", "NULL", "NULLIF", "OF", "OFF", "OFFSETS", "OLD_PASSWORD", "ON", 
		"ON_FAILURE", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", "OPENXML", 
		"OPTION", "OR", "ORDER", "OUTER", "OVER", "PAGE", "PARAM_NODE", "PARTIAL", 
		"PASSWORD", "PERCENT", "PERMISSION_SET", "PER_CPU", "PER_DB", "PER_NODE", 
		"PIVOT", "PLAN", "PLATFORM", "POLICY", "PRECISION", "PREDICATE", "PRIMARY", 
		"PRINT", "PROC", "PROCEDURE", "PROCESS", "PUBLIC", "PYTHON", "R", "RAISERROR", 
		"RAW", "READ", "READTEXT", "READ_WRITE_FILEGROUPS", "RECONFIGURE", "REFERENCES", 
		"REGENERATE", "RELATED_CONVERSATION", "RELATED_CONVERSATION_GROUP", "REPLICATION", 
		"REQUIRED", "RESET", "RESTART", "RESTORE", "RESTRICT", "RESUME", "RETAINDAYS", 
		"RETURN", "RETURNS", "REVERT", "REVOKE", "REWIND", "RIGHT", "ROLLBACK", 
		"ROLE", "ROWCOUNT", "ROWGUIDCOL", "RSA_512", "RSA_1024", "RSA_2048", "RSA_3072", 
		"RSA_4096", "SAFETY", "RULE", "SAFE", "SAVE", "SCHEDULER", "SCHEMA", "SCHEME", 
		"SECURITY", "SECURITYAUDIT", "SELECT", "SEMANTICKEYPHRASETABLE", "SEMANTICSIMILARITYDETAILSTABLE", 
		"SEMANTICSIMILARITYTABLE", "SEQUENCE", "SERVER", "SERVICE", "SERVICE_BROKER", 
		"SERVICE_NAME", "SESSION", "SESSION_USER", "SET", "SETUSER", "SHUTDOWN", 
		"SID", "SKIP_KEYWORD", "SOFTNUMA", "SOME", "SOURCE", "SPECIFICATION", 
		"SPLIT", "SQLDUMPERFLAGS", "SQLDUMPERPATH", "SQLDUMPERTIMEOUT", "STATISTICS", 
		"STATE", "STATS", "START", "STARTED", "STARTUP_STATE", "STOP", "STOPPED", 
		"STOP_ON_ERROR", "SUPPORTED", "SYSTEM", "SYSTEM_USER", "TABLE", "TABLESAMPLE", 
		"TAPE", "TARGET", "TCP", "TEXTSIZE", "THEN", "TO", "TOP", "TRACK_CAUSALITY", 
		"TRAN", "TRANSACTION", "TRANSFER", "TRIGGER", "TRUNCATE", "TSEQUAL", "UNCHECKED", 
		"UNION", "UNIQUE", "UNLOCK", "UNPIVOT", "UNSAFE", "UPDATE", "UPDATETEXT", 
		"URL", "USE", "USED", "USER", "VALUES", "VARYING", "VERBOSELOGGING", "VIEW", 
		"VISIBILITY", "WAITFOR", "WHEN", "WHERE", "WHILE", "WINDOWS", "WITH", 
		"WITHIN", "WITHOUT", "WITNESS", "WRITETEXT", "ABSOLUTE", "ACCENT_SENSITIVITY", 
		"ACTION", "ACTIVATION", "ACTIVE", "ADDRESS", "AES_128", "AES_192", "AES_256", 
		"AFFINITY", "AFTER", "AGGREGATE", "ALGORITHM", "ALLOW_ENCRYPTED_VALUE_MODIFICATIONS", 
		"ALLOW_SNAPSHOT_ISOLATION", "ALLOWED", "ANSI_NULL_DEFAULT", "ANSI_NULLS", 
		"ANSI_PADDING", "ANSI_WARNINGS", "APPLICATION_LOG", "APPLY", "ARITHABORT", 
		"ASSEMBLY", "AUDIT", "AUDIT_GUID", "AUTO", "AUTO_CLEANUP", "AUTO_CLOSE", 
		"AUTO_CREATE_STATISTICS", "AUTO_SHRINK", "AUTO_UPDATE_STATISTICS", "AUTO_UPDATE_STATISTICS_ASYNC", 
		"AVAILABILITY", "AVG", "BACKUP_PRIORITY", "BEGIN_DIALOG", "BIGINT", "BINARY_BASE64", 
		"BINARY_CHECKSUM", "BINDING", "BLOB_STORAGE", "BROKER", "BROKER_INSTANCE", 
		"BULK_LOGGED", "CALLER", "CAP_CPU_PERCENT", "CAST", "CATALOG", "CATCH", 
		"CHANGE_RETENTION", "CHANGE_TRACKING", "CHECKSUM", "CHECKSUM_AGG", "CLEANUP", 
		"COLLECTION", "COLUMN_MASTER_KEY", "COMMITTED", "COMPATIBILITY_LEVEL", 
		"CONCAT", "CONCAT_NULL_YIELDS_NULL", "CONTENT", "CONTROL", "COOKIE", "COUNT", 
		"COUNT_BIG", "COUNTER", "CPU", "CREATE_NEW", "CREATION_DISPOSITION", "CREDENTIAL", 
		"CRYPTOGRAPHIC", "CURSOR_CLOSE_ON_COMMIT", "CURSOR_DEFAULT", "DATE_CORRELATION_OPTIMIZATION", 
		"DATEADD", "DATEDIFF", "DATENAME", "DATEPART", "DAYS", "DB_CHAINING", 
		"DB_FAILOVER", "DECRYPTION", "DEFAULT_DOUBLE_QUOTE", "DEFAULT_FULLTEXT_LANGUAGE", 
		"DEFAULT_LANGUAGE", "DELAY", "DELAYED_DURABILITY", "DELETED", "DENSE_RANK", 
		"DEPENDENTS", "DES", "DESCRIPTION", "DESX", "DHCP", "DIALOG", "DIRECTORY_NAME", 
		"DISABLE", "DISABLE_BROKER", "DISABLED", "DISK_DRIVE", "DOCUMENT", "DYNAMIC", 
		"ELEMENTS", "EMERGENCY", "EMPTY", "ENABLE", "ENABLE_BROKER", "ENCRYPTED_VALUE", 
		"ENCRYPTION", "ENDPOINT_URL", "ERROR_BROKER_CONVERSATIONS", "EXCLUSIVE", 
		"EXECUTABLE", "EXIST", "EXPAND", "EXPIRY_DATE", "EXPLICIT", "FAIL_OPERATION", 
		"FAILOVER_MODE", "FAILURE", "FAILURE_CONDITION_LEVEL", "FAST", "FAST_FORWARD", 
		"FILEGROUP", "FILEGROWTH", "FILEPATH", "FILESTREAM", "FILTER", "FIRST", 
		"FIRST_VALUE", "FOLLOWING", "FORCE", "FORCE_FAILOVER_ALLOW_DATA_LOSS", 
		"FORCED", "FORMAT", "FORWARD_ONLY", "FULLSCAN", "FULLTEXT", "GB", "GETDATE", 
		"GETUTCDATE", "GLOBAL", "GO", "GROUP_MAX_REQUESTS", "GROUPING", "GROUPING_ID", 
		"HADR", "HASH", "HEALTH_CHECK_TIMEOUT", "HIGH", "HONOR_BROKER_PRIORITY", 
		"HOURS", "IDENTITY_VALUE", "IGNORE_NONCLUSTERED_COLUMNSTORE_INDEX", "IMMEDIATE", 
		"IMPERSONATE", "IMPORTANCE", "INCLUDE_NULL_VALUES", "INCREMENTAL", "INITIATOR", 
		"INPUT", "INSENSITIVE", "INSERTED", "INT", "IP", "ISOLATION", "JSON", 
		"KB", "KEEP", "KEEPFIXED", "KEY_SOURCE", "KEYS", "KEYSET", "LAG", "LAST", 
		"LAST_VALUE", "LEAD", "LEVEL", "LIST", "LISTENER", "LISTENER_URL", "LOB_COMPACTION", 
		"LOCAL", "LOCATION", "LOCK", "LOCK_ESCALATION", "LOGIN", "LOOP", "LOW", 
		"MANUAL", "MARK", "MATERIALIZED", "MAX", "MAX_CPU_PERCENT", "MAX_DOP", 
		"MAX_FILES", "MAX_IOPS_PER_VOLUME", "MAX_MEMORY_PERCENT", "MAX_PROCESSES", 
		"MAX_QUEUE_READERS", "MAX_ROLLOVER_FILES", "MAXDOP", "MAXRECURSION", "MAXSIZE", 
		"MB", "MEDIUM", "MEMORY_OPTIMIZED_DATA", "MESSAGE", "MIN", "MIN_ACTIVE_ROWVERSION", 
		"MIN_CPU_PERCENT", "MIN_IOPS_PER_VOLUME", "MIN_MEMORY_PERCENT", "MINUTES", 
		"MIRROR_ADDRESS", "MIXED_PAGE_ALLOCATION", "MODE", "MODIFY", "MOVE", "MULTI_USER", 
		"NAME", "NESTED_TRIGGERS", "NEW_ACCOUNT", "NEW_BROKER", "NEW_PASSWORD", 
		"NEXT", "NO", "NO_TRUNCATE", "NO_WAIT", "NOCOUNT", "NODES", "NOEXPAND", 
		"NON_TRANSACTED_ACCESS", "NORECOMPUTE", "NORECOVERY", "NOWAIT", "NTILE", 
		"NUMANODE", "NUMBER", "NUMERIC_ROUNDABORT", "OBJECT", "OFFLINE", "OFFSET", 
		"OLD_ACCOUNT", "ONLINE", "ONLY", "OPEN_EXISTING", "OPTIMISTIC", "OPTIMIZE", 
		"OUT", "OUTPUT", "OWNER", "PAGE_VERIFY", "PARAMETERIZATION", "PARTITION", 
		"PARTITIONS", "PARTNER", "PATH", "POISON_MESSAGE_HANDLING", "POOL", "PORT", 
		"PRECEDING", "PRIMARY_ROLE", "PRIOR", "PRIORITY", "PRIORITY_LEVEL", "PRIVATE", 
		"PRIVATE_KEY", "PRIVILEGES", "PROCEDURE_NAME", "PROPERTY", "PROVIDER", 
		"PROVIDER_KEY_NAME", "QUERY", "QUEUE", "QUEUE_DELAY", "QUOTED_IDENTIFIER", 
		"RANGE", "RANK", "RC2", "RC4", "RC4_128", "READ_COMMITTED_SNAPSHOT", "READ_ONLY", 
		"READ_ONLY_ROUTING_LIST", "READ_WRITE", "READONLY", "REBUILD", "RECEIVE", 
		"RECOMPILE", "RECOVERY", "RECURSIVE_TRIGGERS", "RELATIVE", "REMOTE", "REMOTE_SERVICE_NAME", 
		"REMOVE", "REORGANIZE", "REPEATABLE", "REPLICA", "REQUEST_MAX_CPU_TIME_SEC", 
		"REQUEST_MAX_MEMORY_GRANT_PERCENT", "REQUEST_MEMORY_GRANT_TIMEOUT_SEC", 
		"REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT", "RESERVE_DISK_SPACE", "RESOURCE", 
		"RESOURCE_MANAGER_LOCATION", "RESTRICTED_USER", "RETENTION", "ROBUST", 
		"ROOT", "ROUTE", "ROW", "ROW_NUMBER", "ROWGUID", "ROWS", "SAMPLE", "SCHEMABINDING", 
		"SCOPED", "SCROLL", "SCROLL_LOCKS", "SEARCH", "SECONDARY", "SECONDARY_ONLY", 
		"SECONDARY_ROLE", "SECONDS", "SECRET", "SECURITY_LOG", "SEEDING_MODE", 
		"SELF", "SEMI_SENSITIVE", "SEND", "SENT", "SERIALIZABLE", "SESSION_TIMEOUT", 
		"SETERROR", "SHARE", "SHOWPLAN", "SIGNATURE", "SIMPLE", "SINGLE_USER", 
		"SIZE", "SMALLINT", "SNAPSHOT", "SPATIAL_WINDOW_MAX_CELLS", "STANDBY", 
		"START_DATE", "STATIC", "STATS_STREAM", "STATUS", "STDEV", "STDEVP", "STOPLIST", 
		"STUFF", "SUBJECT", "SUM", "SUSPEND", "SYMMETRIC", "SYNCHRONOUS_COMMIT", 
		"SYNONYM", "TAKE", "TARGET_RECOVERY_TIME", "TB", "TEXTIMAGE_ON", "THROW", 
		"TIES", "TIME", "TIMEOUT", "TIMER", "TINYINT", "TORN_PAGE_DETECTION", 
		"TRANSFORM_NOISE_WORDS", "TRIPLE_DES", "TRIPLE_DES_3KEY", "TRUSTWORTHY", 
		"TRY", "TSQL", "TWO_DIGIT_YEAR_CUTOFF", "TYPE", "TYPE_WARNING", "UNBOUNDED", 
		"UNCOMMITTED", "UNKNOWN", "UNLIMITED", "USING", "VALID_XML", "VALIDATION", 
		"VALUE", "VAR", "VARP", "VIEW_METADATA", "VIEWS", "WAIT", "WELL_FORMED_XML", 
		"WITHOUT_ARRAY_WRAPPER", "WORK", "WORKLOAD", "XML", "XMLDATA", "XMLNAMESPACES", 
		"XMLSCHEMA", "XSINIL", "DOLLAR_ACTION", "SPACE", "COMMENT", "LINE_COMMENT", 
		"DOUBLE_QUOTE_ID", "SINGLE_QUOTE", "SQUARE_BRACKET_ID", "LOCAL_ID", "DECIMAL", 
		"ID", "QUOTED_URL", "QUOTED_HOST_AND_PORT", "STRING", "BINARY", "FLOAT", 
		"REAL", "EQUAL", "GREATER", "LESS", "EXCLAMATION", "PLUS_ASSIGN", "MINUS_ASSIGN", 
		"MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", 
		"OR_ASSIGN", "DOUBLE_BAR", "DOT", "UNDERLINE", "AT", "SHARP", "DOLLAR", 
		"LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "COLON", "STAR", "DIVIDE", 
		"MODULE", "PLUS", "MINUS", "BIT_NOT", "BIT_OR", "BIT_AND", "BIT_XOR", 
		"IPV4_OCTECT"
	};
	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	@Deprecated
	public static final String[] tokenNames;
	static {
		tokenNames = new String[_SYMBOLIC_NAMES.length];
		for (int i = 0; i < tokenNames.length; i++) {
			tokenNames[i] = VOCABULARY.getLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = VOCABULARY.getSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}
	}

	@Override
	@Deprecated
	public String[] getTokenNames() {
		return tokenNames;
	}

	@Override

	public Vocabulary getVocabulary() {
		return VOCABULARY;
	}

	@Override
	public String getGrammarFileName() { return "SearchExprs.g4"; }

	@Override
	public String[] getRuleNames() { return ruleNames; }

	@Override
	public String getSerializedATN() { return _serializedATN; }

	@Override
	public ATN getATN() { return _ATN; }

	public SearchExprs(TokenStream input) {
		super(input);
		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
	}
	public static class Search_conditionContext extends ParserRuleContext {
		public List<Search_condition_andContext> search_condition_and() {
			return getRuleContexts(Search_condition_andContext.class);
		}
		public Search_condition_andContext search_condition_and(int i) {
			return getRuleContext(Search_condition_andContext.class,i);
		}
		public List<TerminalNode> OR() { return getTokens(SearchExprs.OR); }
		public TerminalNode OR(int i) {
			return getToken(SearchExprs.OR, i);
		}
		public Search_conditionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_search_condition; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterSearch_condition(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitSearch_condition(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitSearch_condition(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Search_conditionContext search_condition() throws RecognitionException {
		Search_conditionContext _localctx = new Search_conditionContext(_ctx, getState());
		enterRule(_localctx, 0, RULE_search_condition);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(40);
			search_condition_and();
			setState(45);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==OR) {
				{
				{
				setState(41);
				match(OR);
				setState(42);
				search_condition_and();
				}
				}
				setState(47);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Search_condition_andContext extends ParserRuleContext {
		public List<Search_condition_notContext> search_condition_not() {
			return getRuleContexts(Search_condition_notContext.class);
		}
		public Search_condition_notContext search_condition_not(int i) {
			return getRuleContext(Search_condition_notContext.class,i);
		}
		public List<TerminalNode> AND() { return getTokens(SearchExprs.AND); }
		public TerminalNode AND(int i) {
			return getToken(SearchExprs.AND, i);
		}
		public Search_condition_andContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_search_condition_and; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterSearch_condition_and(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitSearch_condition_and(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitSearch_condition_and(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Search_condition_andContext search_condition_and() throws RecognitionException {
		Search_condition_andContext _localctx = new Search_condition_andContext(_ctx, getState());
		enterRule(_localctx, 2, RULE_search_condition_and);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(48);
			search_condition_not();
			setState(53);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==AND) {
				{
				{
				setState(49);
				match(AND);
				setState(50);
				search_condition_not();
				}
				}
				setState(55);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Search_condition_notContext extends ParserRuleContext {
		public PredicateContext predicate() {
			return getRuleContext(PredicateContext.class,0);
		}
		public TerminalNode NOT() { return getToken(SearchExprs.NOT, 0); }
		public Search_condition_notContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_search_condition_not; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterSearch_condition_not(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitSearch_condition_not(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitSearch_condition_not(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Search_condition_notContext search_condition_not() throws RecognitionException {
		Search_condition_notContext _localctx = new Search_condition_notContext(_ctx, getState());
		enterRule(_localctx, 4, RULE_search_condition_not);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(57);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==NOT) {
				{
				setState(56);
				match(NOT);
				}
			}

			setState(59);
			predicate();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class PredicateContext extends ParserRuleContext {
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public Comparison_operatorContext comparison_operator() {
			return getRuleContext(Comparison_operatorContext.class,0);
		}
		public TerminalNode IN() { return getToken(SearchExprs.IN, 0); }
		public Expression_listContext expression_list() {
			return getRuleContext(Expression_listContext.class,0);
		}
		public TerminalNode NOT() { return getToken(SearchExprs.NOT, 0); }
		public TerminalNode LIKE() { return getToken(SearchExprs.LIKE, 0); }
		public TerminalNode IS() { return getToken(SearchExprs.IS, 0); }
		public Null_notnullContext null_notnull() {
			return getRuleContext(Null_notnullContext.class,0);
		}
		public Search_conditionContext search_condition() {
			return getRuleContext(Search_conditionContext.class,0);
		}
		public PredicateContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_predicate; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterPredicate(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitPredicate(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitPredicate(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PredicateContext predicate() throws RecognitionException {
		PredicateContext _localctx = new PredicateContext(_ctx, getState());
		enterRule(_localctx, 6, RULE_predicate);
		int _la;
		try {
			setState(89);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,5,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(61);
				expression(0);
				setState(62);
				comparison_operator();
				setState(63);
				expression(0);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(65);
				expression(0);
				setState(67);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==NOT) {
					{
					setState(66);
					match(NOT);
					}
				}

				setState(69);
				match(IN);
				setState(70);
				match(LR_BRACKET);
				setState(71);
				expression_list();
				setState(72);
				match(RR_BRACKET);
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(74);
				expression(0);
				setState(76);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==NOT) {
					{
					setState(75);
					match(NOT);
					}
				}

				setState(78);
				match(LIKE);
				setState(79);
				expression(0);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(81);
				expression(0);
				setState(82);
				match(IS);
				setState(83);
				null_notnull();
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(85);
				match(LR_BRACKET);
				setState(86);
				search_condition();
				setState(87);
				match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Expression_listContext extends ParserRuleContext {
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public Expression_listContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expression_list; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterExpression_list(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitExpression_list(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitExpression_list(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Expression_listContext expression_list() throws RecognitionException {
		Expression_listContext _localctx = new Expression_listContext(_ctx, getState());
		enterRule(_localctx, 8, RULE_expression_list);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(91);
			expression(0);
			setState(96);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==COMMA) {
				{
				{
				setState(92);
				match(COMMA);
				setState(93);
				expression(0);
				}
				}
				setState(98);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ExpressionContext extends ParserRuleContext {
		public Token op;
		public Function_callContext function_call() {
			return getRuleContext(Function_callContext.class,0);
		}
		public Full_column_nameContext full_column_name() {
			return getRuleContext(Full_column_nameContext.class,0);
		}
		public Bracket_expressionContext bracket_expression() {
			return getRuleContext(Bracket_expressionContext.class,0);
		}
		public Unary_operator_expressionContext unary_operator_expression() {
			return getRuleContext(Unary_operator_expressionContext.class,0);
		}
		public Constant_expressionContext constant_expression() {
			return getRuleContext(Constant_expressionContext.class,0);
		}
		public List<ExpressionContext> expression() {
			return getRuleContexts(ExpressionContext.class);
		}
		public ExpressionContext expression(int i) {
			return getRuleContext(ExpressionContext.class,i);
		}
		public Comparison_operatorContext comparison_operator() {
			return getRuleContext(Comparison_operatorContext.class,0);
		}
		public Assignment_operatorContext assignment_operator() {
			return getRuleContext(Assignment_operatorContext.class,0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExpressionContext expression() throws RecognitionException {
		return expression(0);
	}

	private ExpressionContext expression(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 10;
		enterRecursionRule(_localctx, 10, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(105);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,7,_ctx) ) {
			case 1:
				{
				setState(100);
				function_call();
				}
				break;
			case 2:
				{
				setState(101);
				full_column_name();
				}
				break;
			case 3:
				{
				setState(102);
				bracket_expression();
				}
				break;
			case 4:
				{
				setState(103);
				unary_operator_expression();
				}
				break;
			case 5:
				{
				setState(104);
				constant_expression();
				}
				break;
			}
			_ctx.stop = _input.LT(-1);
			setState(123);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,9,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					setState(121);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,8,_ctx) ) {
					case 1:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_expression);
						setState(107);
						if (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, "precpred(_ctx, 5)");
						setState(108);
						((ExpressionContext)_localctx).op = _input.LT(1);
						_la = _input.LA(1);
						if ( !(((((_la - 826)) & ~0x3f) == 0 && ((1L << (_la - 826)) & ((1L << (STAR - 826)) | (1L << (DIVIDE - 826)) | (1L << (MODULE - 826)))) != 0)) ) {
							((ExpressionContext)_localctx).op = (Token)_errHandler.recoverInline(this);
						}
						else {
							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
							_errHandler.reportMatch(this);
							consume();
						}
						setState(109);
						expression(6);
						}
						break;
					case 2:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_expression);
						setState(110);
						if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, "precpred(_ctx, 4)");
						setState(111);
						((ExpressionContext)_localctx).op = _input.LT(1);
						_la = _input.LA(1);
						if ( !(((((_la - 815)) & ~0x3f) == 0 && ((1L << (_la - 815)) & ((1L << (DOUBLE_BAR - 815)) | (1L << (PLUS - 815)) | (1L << (MINUS - 815)) | (1L << (BIT_OR - 815)) | (1L << (BIT_AND - 815)) | (1L << (BIT_XOR - 815)))) != 0)) ) {
							((ExpressionContext)_localctx).op = (Token)_errHandler.recoverInline(this);
						}
						else {
							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
							_errHandler.reportMatch(this);
							consume();
						}
						setState(112);
						expression(5);
						}
						break;
					case 3:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_expression);
						setState(113);
						if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, "precpred(_ctx, 3)");
						setState(114);
						comparison_operator();
						setState(115);
						expression(4);
						}
						break;
					case 4:
						{
						_localctx = new ExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_expression);
						setState(117);
						if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, "precpred(_ctx, 2)");
						setState(118);
						assignment_operator();
						setState(119);
						expression(3);
						}
						break;
					}
					} 
				}
				setState(125);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,9,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public static class Function_callContext extends ParserRuleContext {
		public Aggregate_windowed_functionContext aggregate_windowed_function() {
			return getRuleContext(Aggregate_windowed_functionContext.class,0);
		}
		public Func_proc_nameContext func_proc_name() {
			return getRuleContext(Func_proc_nameContext.class,0);
		}
		public Expression_listContext expression_list() {
			return getRuleContext(Expression_listContext.class,0);
		}
		public Function_callContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_function_call; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterFunction_call(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitFunction_call(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitFunction_call(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Function_callContext function_call() throws RecognitionException {
		Function_callContext _localctx = new Function_callContext(_ctx, getState());
		enterRule(_localctx, 12, RULE_function_call);
		int _la;
		try {
			setState(134);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,11,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(126);
				aggregate_windowed_function();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(127);
				func_proc_name();
				setState(128);
				match(LR_BRACKET);
				setState(130);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==BLOCKING_HIERARCHY || _la==INIT || _la==NULL || _la==ROWCOUNT || ((((_la - 396)) & ~0x3f) == 0 && ((1L << (_la - 396)) & ((1L << (AGGREGATE - 396)) | (1L << (AVG - 396)) | (1L << (BIGINT - 396)) | (1L << (BINARY_BASE64 - 396)) | (1L << (COUNT - 396)) | (1L << (COUNT_BIG - 396)) | (1L << (COUNTER - 396)))) != 0) || ((((_la - 460)) & ~0x3f) == 0 && ((1L << (_la - 460)) & ((1L << (DATEADD - 460)) | (1L << (DATEDIFF - 460)) | (1L << (DATENAME - 460)) | (1L << (DATEPART - 460)) | (1L << (DAYS - 460)) | (1L << (FIRST - 460)) | (1L << (FIRST_VALUE - 460)) | (1L << (FOLLOWING - 460)))) != 0) || ((((_la - 537)) & ~0x3f) == 0 && ((1L << (_la - 537)) & ((1L << (HOURS - 537)) | (1L << (IDENTITY_VALUE - 537)) | (1L << (INT - 537)) | (1L << (LAST - 537)) | (1L << (LAST_VALUE - 537)) | (1L << (LOW - 537)) | (1L << (MAX - 537)) | (1L << (MIN - 537)) | (1L << (MINUTES - 537)))) != 0) || _la==NUMBER || ((((_la - 697)) & ~0x3f) == 0 && ((1L << (_la - 697)) & ((1L << (ROW - 697)) | (1L << (ROW_NUMBER - 697)) | (1L << (STDEV - 697)) | (1L << (STDEVP - 697)) | (1L << (SUM - 697)) | (1L << (TIME - 697)))) != 0) || ((((_la - 773)) & ~0x3f) == 0 && ((1L << (_la - 773)) & ((1L << (VAR - 773)) | (1L << (VARP - 773)) | (1L << (DECIMAL - 773)) | (1L << (ID - 773)) | (1L << (STRING - 773)) | (1L << (BINARY - 773)) | (1L << (FLOAT - 773)) | (1L << (REAL - 773)) | (1L << (LR_BRACKET - 773)) | (1L << (PLUS - 773)) | (1L << (MINUS - 773)) | (1L << (BIT_NOT - 773)))) != 0)) {
					{
					setState(129);
					expression_list();
					}
				}

				setState(132);
				match(RR_BRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Aggregate_windowed_functionContext extends ParserRuleContext {
		public Full_column_nameContext full_column_name() {
			return getRuleContext(Full_column_nameContext.class,0);
		}
		public TerminalNode AVG() { return getToken(SearchExprs.AVG, 0); }
		public TerminalNode MAX() { return getToken(SearchExprs.MAX, 0); }
		public TerminalNode MIN() { return getToken(SearchExprs.MIN, 0); }
		public TerminalNode SUM() { return getToken(SearchExprs.SUM, 0); }
		public TerminalNode STDEV() { return getToken(SearchExprs.STDEV, 0); }
		public TerminalNode STDEVP() { return getToken(SearchExprs.STDEVP, 0); }
		public TerminalNode VAR() { return getToken(SearchExprs.VAR, 0); }
		public TerminalNode VARP() { return getToken(SearchExprs.VARP, 0); }
		public TerminalNode COUNT() { return getToken(SearchExprs.COUNT, 0); }
		public TerminalNode COUNT_BIG() { return getToken(SearchExprs.COUNT_BIG, 0); }
		public Aggregate_windowed_functionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_aggregate_windowed_function; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterAggregate_windowed_function(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitAggregate_windowed_function(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitAggregate_windowed_function(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Aggregate_windowed_functionContext aggregate_windowed_function() throws RecognitionException {
		Aggregate_windowed_functionContext _localctx = new Aggregate_windowed_functionContext(_ctx, getState());
		enterRule(_localctx, 14, RULE_aggregate_windowed_function);
		int _la;
		try {
			setState(148);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case AVG:
			case MAX:
			case MIN:
			case STDEV:
			case STDEVP:
			case SUM:
			case VAR:
			case VARP:
				enterOuterAlt(_localctx, 1);
				{
				setState(136);
				_la = _input.LA(1);
				if ( !(_la==AVG || _la==MAX || _la==MIN || ((((_la - 735)) & ~0x3f) == 0 && ((1L << (_la - 735)) & ((1L << (STDEV - 735)) | (1L << (STDEVP - 735)) | (1L << (SUM - 735)) | (1L << (VAR - 735)) | (1L << (VARP - 735)))) != 0)) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(137);
				match(LR_BRACKET);
				setState(138);
				full_column_name();
				setState(139);
				match(RR_BRACKET);
				}
				break;
			case COUNT:
			case COUNT_BIG:
				enterOuterAlt(_localctx, 2);
				{
				setState(141);
				_la = _input.LA(1);
				if ( !(_la==COUNT || _la==COUNT_BIG) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(142);
				match(LR_BRACKET);
				setState(145);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case STAR:
					{
					setState(143);
					match(STAR);
					}
					break;
				case BLOCKING_HIERARCHY:
				case INIT:
				case ROWCOUNT:
				case AGGREGATE:
				case AVG:
				case BIGINT:
				case BINARY_BASE64:
				case COUNT:
				case COUNT_BIG:
				case COUNTER:
				case DATEADD:
				case DATEDIFF:
				case DATENAME:
				case DATEPART:
				case DAYS:
				case FIRST:
				case FIRST_VALUE:
				case FOLLOWING:
				case HOURS:
				case IDENTITY_VALUE:
				case INT:
				case LAST:
				case LAST_VALUE:
				case LOW:
				case MAX:
				case MIN:
				case MINUTES:
				case NUMBER:
				case ROW:
				case ROW_NUMBER:
				case SUM:
				case TIME:
				case ID:
					{
					setState(144);
					full_column_name();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(147);
				match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Func_proc_nameContext extends ParserRuleContext {
		public IdContext procedure;
		public IdContext id() {
			return getRuleContext(IdContext.class,0);
		}
		public Func_proc_nameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_func_proc_name; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterFunc_proc_name(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitFunc_proc_name(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitFunc_proc_name(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Func_proc_nameContext func_proc_name() throws RecognitionException {
		Func_proc_nameContext _localctx = new Func_proc_nameContext(_ctx, getState());
		enterRule(_localctx, 16, RULE_func_proc_name);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(150);
			((Func_proc_nameContext)_localctx).procedure = id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Full_column_nameContext extends ParserRuleContext {
		public IdContext column_name;
		public IdContext id() {
			return getRuleContext(IdContext.class,0);
		}
		public Table_nameContext table_name() {
			return getRuleContext(Table_nameContext.class,0);
		}
		public Full_column_nameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_full_column_name; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterFull_column_name(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitFull_column_name(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitFull_column_name(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Full_column_nameContext full_column_name() throws RecognitionException {
		Full_column_nameContext _localctx = new Full_column_nameContext(_ctx, getState());
		enterRule(_localctx, 18, RULE_full_column_name);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(155);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,14,_ctx) ) {
			case 1:
				{
				setState(152);
				table_name();
				setState(153);
				match(DOT);
				}
				break;
			}
			setState(157);
			((Full_column_nameContext)_localctx).column_name = id();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Table_nameContext extends ParserRuleContext {
		public IdContext database;
		public IdContext schema;
		public IdContext table;
		public List<IdContext> id() {
			return getRuleContexts(IdContext.class);
		}
		public IdContext id(int i) {
			return getRuleContext(IdContext.class,i);
		}
		public TerminalNode BLOCKING_HIERARCHY() { return getToken(SearchExprs.BLOCKING_HIERARCHY, 0); }
		public Table_nameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_table_name; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterTable_name(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitTable_name(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitTable_name(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Table_nameContext table_name() throws RecognitionException {
		Table_nameContext _localctx = new Table_nameContext(_ctx, getState());
		enterRule(_localctx, 20, RULE_table_name);
		int _la;
		try {
			setState(185);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,19,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(169);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,16,_ctx) ) {
				case 1:
					{
					setState(159);
					((Table_nameContext)_localctx).database = id();
					setState(160);
					match(DOT);
					setState(162);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==INIT || _la==ROWCOUNT || ((((_la - 396)) & ~0x3f) == 0 && ((1L << (_la - 396)) & ((1L << (AGGREGATE - 396)) | (1L << (AVG - 396)) | (1L << (BIGINT - 396)) | (1L << (BINARY_BASE64 - 396)) | (1L << (COUNT - 396)) | (1L << (COUNT_BIG - 396)) | (1L << (COUNTER - 396)))) != 0) || ((((_la - 460)) & ~0x3f) == 0 && ((1L << (_la - 460)) & ((1L << (DATEADD - 460)) | (1L << (DATEDIFF - 460)) | (1L << (DATENAME - 460)) | (1L << (DATEPART - 460)) | (1L << (DAYS - 460)) | (1L << (FIRST - 460)) | (1L << (FIRST_VALUE - 460)) | (1L << (FOLLOWING - 460)))) != 0) || ((((_la - 537)) & ~0x3f) == 0 && ((1L << (_la - 537)) & ((1L << (HOURS - 537)) | (1L << (IDENTITY_VALUE - 537)) | (1L << (INT - 537)) | (1L << (LAST - 537)) | (1L << (LAST_VALUE - 537)) | (1L << (LOW - 537)) | (1L << (MAX - 537)) | (1L << (MIN - 537)) | (1L << (MINUTES - 537)))) != 0) || _la==NUMBER || ((((_la - 697)) & ~0x3f) == 0 && ((1L << (_la - 697)) & ((1L << (ROW - 697)) | (1L << (ROW_NUMBER - 697)) | (1L << (SUM - 697)) | (1L << (TIME - 697)))) != 0) || _la==ID) {
						{
						setState(161);
						((Table_nameContext)_localctx).schema = id();
						}
					}

					setState(164);
					match(DOT);
					}
					break;
				case 2:
					{
					setState(166);
					((Table_nameContext)_localctx).schema = id();
					setState(167);
					match(DOT);
					}
					break;
				}
				setState(171);
				((Table_nameContext)_localctx).table = id();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(182);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,18,_ctx) ) {
				case 1:
					{
					setState(172);
					((Table_nameContext)_localctx).database = id();
					setState(173);
					match(DOT);
					setState(175);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==INIT || _la==ROWCOUNT || ((((_la - 396)) & ~0x3f) == 0 && ((1L << (_la - 396)) & ((1L << (AGGREGATE - 396)) | (1L << (AVG - 396)) | (1L << (BIGINT - 396)) | (1L << (BINARY_BASE64 - 396)) | (1L << (COUNT - 396)) | (1L << (COUNT_BIG - 396)) | (1L << (COUNTER - 396)))) != 0) || ((((_la - 460)) & ~0x3f) == 0 && ((1L << (_la - 460)) & ((1L << (DATEADD - 460)) | (1L << (DATEDIFF - 460)) | (1L << (DATENAME - 460)) | (1L << (DATEPART - 460)) | (1L << (DAYS - 460)) | (1L << (FIRST - 460)) | (1L << (FIRST_VALUE - 460)) | (1L << (FOLLOWING - 460)))) != 0) || ((((_la - 537)) & ~0x3f) == 0 && ((1L << (_la - 537)) & ((1L << (HOURS - 537)) | (1L << (IDENTITY_VALUE - 537)) | (1L << (INT - 537)) | (1L << (LAST - 537)) | (1L << (LAST_VALUE - 537)) | (1L << (LOW - 537)) | (1L << (MAX - 537)) | (1L << (MIN - 537)) | (1L << (MINUTES - 537)))) != 0) || _la==NUMBER || ((((_la - 697)) & ~0x3f) == 0 && ((1L << (_la - 697)) & ((1L << (ROW - 697)) | (1L << (ROW_NUMBER - 697)) | (1L << (SUM - 697)) | (1L << (TIME - 697)))) != 0) || _la==ID) {
						{
						setState(174);
						((Table_nameContext)_localctx).schema = id();
						}
					}

					setState(177);
					match(DOT);
					}
					break;
				case 2:
					{
					setState(179);
					((Table_nameContext)_localctx).schema = id();
					setState(180);
					match(DOT);
					}
					break;
				}
				setState(184);
				match(BLOCKING_HIERARCHY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Unary_operator_expressionContext extends ParserRuleContext {
		public Token op;
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public Unary_operator_expressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_unary_operator_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterUnary_operator_expression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitUnary_operator_expression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitUnary_operator_expression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Unary_operator_expressionContext unary_operator_expression() throws RecognitionException {
		Unary_operator_expressionContext _localctx = new Unary_operator_expressionContext(_ctx, getState());
		enterRule(_localctx, 22, RULE_unary_operator_expression);
		int _la;
		try {
			setState(191);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case BIT_NOT:
				enterOuterAlt(_localctx, 1);
				{
				setState(187);
				match(BIT_NOT);
				setState(188);
				expression(0);
				}
				break;
			case PLUS:
			case MINUS:
				enterOuterAlt(_localctx, 2);
				{
				setState(189);
				((Unary_operator_expressionContext)_localctx).op = _input.LT(1);
				_la = _input.LA(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
					((Unary_operator_expressionContext)_localctx).op = (Token)_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(190);
				expression(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Bracket_expressionContext extends ParserRuleContext {
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public Bracket_expressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_bracket_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterBracket_expression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitBracket_expression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitBracket_expression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Bracket_expressionContext bracket_expression() throws RecognitionException {
		Bracket_expressionContext _localctx = new Bracket_expressionContext(_ctx, getState());
		enterRule(_localctx, 24, RULE_bracket_expression);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(193);
			match(LR_BRACKET);
			setState(194);
			expression(0);
			setState(195);
			match(RR_BRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Constant_expressionContext extends ParserRuleContext {
		public TerminalNode NULL() { return getToken(SearchExprs.NULL, 0); }
		public ConstantContext constant() {
			return getRuleContext(ConstantContext.class,0);
		}
		public Function_callContext function_call() {
			return getRuleContext(Function_callContext.class,0);
		}
		public Constant_expressionContext constant_expression() {
			return getRuleContext(Constant_expressionContext.class,0);
		}
		public Constant_expressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_constant_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterConstant_expression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitConstant_expression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitConstant_expression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Constant_expressionContext constant_expression() throws RecognitionException {
		Constant_expressionContext _localctx = new Constant_expressionContext(_ctx, getState());
		enterRule(_localctx, 26, RULE_constant_expression);
		try {
			setState(204);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case NULL:
				enterOuterAlt(_localctx, 1);
				{
				setState(197);
				match(NULL);
				}
				break;
			case DECIMAL:
			case STRING:
			case BINARY:
			case FLOAT:
			case REAL:
			case PLUS:
			case MINUS:
				enterOuterAlt(_localctx, 2);
				{
				setState(198);
				constant();
				}
				break;
			case INIT:
			case ROWCOUNT:
			case AGGREGATE:
			case AVG:
			case BIGINT:
			case BINARY_BASE64:
			case COUNT:
			case COUNT_BIG:
			case COUNTER:
			case DATEADD:
			case DATEDIFF:
			case DATENAME:
			case DATEPART:
			case DAYS:
			case FIRST:
			case FIRST_VALUE:
			case FOLLOWING:
			case HOURS:
			case IDENTITY_VALUE:
			case INT:
			case LAST:
			case LAST_VALUE:
			case LOW:
			case MAX:
			case MIN:
			case MINUTES:
			case NUMBER:
			case ROW:
			case ROW_NUMBER:
			case STDEV:
			case STDEVP:
			case SUM:
			case TIME:
			case VAR:
			case VARP:
			case ID:
				enterOuterAlt(_localctx, 3);
				{
				setState(199);
				function_call();
				}
				break;
			case LR_BRACKET:
				enterOuterAlt(_localctx, 4);
				{
				setState(200);
				match(LR_BRACKET);
				setState(201);
				constant_expression();
				setState(202);
				match(RR_BRACKET);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Comparison_operatorContext extends ParserRuleContext {
		public Comparison_operatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_comparison_operator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterComparison_operator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitComparison_operator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitComparison_operator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Comparison_operatorContext comparison_operator() throws RecognitionException {
		Comparison_operatorContext _localctx = new Comparison_operatorContext(_ctx, getState());
		enterRule(_localctx, 28, RULE_comparison_operator);
		try {
			setState(226);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,22,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(206);
				match(EQUAL);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(207);
				match(GREATER);
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(208);
				match(LESS);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(209);
				match(LESS);
				setState(210);
				match(EQUAL);
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(211);
				match(GREATER);
				setState(212);
				match(EQUAL);
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(213);
				match(LESS);
				setState(214);
				match(GREATER);
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(215);
				match(EXCLAMATION);
				setState(216);
				match(EQUAL);
				}
				break;
			case 8:
				enterOuterAlt(_localctx, 8);
				{
				setState(217);
				match(EXCLAMATION);
				setState(218);
				match(GREATER);
				}
				break;
			case 9:
				enterOuterAlt(_localctx, 9);
				{
				setState(219);
				match(EXCLAMATION);
				setState(220);
				match(LESS);
				}
				break;
			case 10:
				enterOuterAlt(_localctx, 10);
				{
				setState(221);
				match(MODULE);
				setState(222);
				match(BIT_NOT);
				}
				break;
			case 11:
				enterOuterAlt(_localctx, 11);
				{
				setState(223);
				match(MODULE);
				}
				break;
			case 12:
				enterOuterAlt(_localctx, 12);
				{
				setState(224);
				match(BIT_NOT);
				setState(225);
				match(MODULE);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Assignment_operatorContext extends ParserRuleContext {
		public Assignment_operatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_assignment_operator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterAssignment_operator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitAssignment_operator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitAssignment_operator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Assignment_operatorContext assignment_operator() throws RecognitionException {
		Assignment_operatorContext _localctx = new Assignment_operatorContext(_ctx, getState());
		enterRule(_localctx, 30, RULE_assignment_operator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(228);
			_la = _input.LA(1);
			if ( !(((((_la - 807)) & ~0x3f) == 0 && ((1L << (_la - 807)) & ((1L << (PLUS_ASSIGN - 807)) | (1L << (MINUS_ASSIGN - 807)) | (1L << (MULT_ASSIGN - 807)) | (1L << (DIV_ASSIGN - 807)) | (1L << (MOD_ASSIGN - 807)) | (1L << (AND_ASSIGN - 807)) | (1L << (XOR_ASSIGN - 807)) | (1L << (OR_ASSIGN - 807)))) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class Null_notnullContext extends ParserRuleContext {
		public TerminalNode NULL() { return getToken(SearchExprs.NULL, 0); }
		public TerminalNode NOT() { return getToken(SearchExprs.NOT, 0); }
		public Null_notnullContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_null_notnull; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterNull_notnull(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitNull_notnull(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitNull_notnull(this);
			else return visitor.visitChildren(this);
		}
	}

	public final Null_notnullContext null_notnull() throws RecognitionException {
		Null_notnullContext _localctx = new Null_notnullContext(_ctx, getState());
		enterRule(_localctx, 32, RULE_null_notnull);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(231);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==NOT) {
				{
				setState(230);
				match(NOT);
				}
			}

			setState(233);
			match(NULL);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class ConstantContext extends ParserRuleContext {
		public TerminalNode STRING() { return getToken(SearchExprs.STRING, 0); }
		public TerminalNode BINARY() { return getToken(SearchExprs.BINARY, 0); }
		public TerminalNode DECIMAL() { return getToken(SearchExprs.DECIMAL, 0); }
		public SignContext sign() {
			return getRuleContext(SignContext.class,0);
		}
		public TerminalNode REAL() { return getToken(SearchExprs.REAL, 0); }
		public TerminalNode FLOAT() { return getToken(SearchExprs.FLOAT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_constant; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterConstant(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitConstant(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitConstant(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConstantContext constant() throws RecognitionException {
		ConstantContext _localctx = new ConstantContext(_ctx, getState());
		enterRule(_localctx, 34, RULE_constant);
		int _la;
		try {
			setState(245);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,26,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(235);
				match(STRING);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(236);
				match(BINARY);
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(238);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==PLUS || _la==MINUS) {
					{
					setState(237);
					sign();
					}
				}

				setState(240);
				match(DECIMAL);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(242);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==PLUS || _la==MINUS) {
					{
					setState(241);
					sign();
					}
				}

				setState(244);
				_la = _input.LA(1);
				if ( !(_la==FLOAT || _la==REAL) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class SignContext extends ParserRuleContext {
		public SignContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_sign; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterSign(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitSign(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitSign(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SignContext sign() throws RecognitionException {
		SignContext _localctx = new SignContext(_ctx, getState());
		enterRule(_localctx, 36, RULE_sign);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(247);
			_la = _input.LA(1);
			if ( !(_la==PLUS || _la==MINUS) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public static class IdContext extends ParserRuleContext {
		public TerminalNode ID() { return getToken(SearchExprs.ID, 0); }
		public TerminalNode AGGREGATE() { return getToken(SearchExprs.AGGREGATE, 0); }
		public TerminalNode AVG() { return getToken(SearchExprs.AVG, 0); }
		public TerminalNode BIGINT() { return getToken(SearchExprs.BIGINT, 0); }
		public TerminalNode BINARY_BASE64() { return getToken(SearchExprs.BINARY_BASE64, 0); }
		public TerminalNode COUNT() { return getToken(SearchExprs.COUNT, 0); }
		public TerminalNode COUNT_BIG() { return getToken(SearchExprs.COUNT_BIG, 0); }
		public TerminalNode COUNTER() { return getToken(SearchExprs.COUNTER, 0); }
		public TerminalNode DATEADD() { return getToken(SearchExprs.DATEADD, 0); }
		public TerminalNode DATEDIFF() { return getToken(SearchExprs.DATEDIFF, 0); }
		public TerminalNode DATENAME() { return getToken(SearchExprs.DATENAME, 0); }
		public TerminalNode DATEPART() { return getToken(SearchExprs.DATEPART, 0); }
		public TerminalNode DAYS() { return getToken(SearchExprs.DAYS, 0); }
		public TerminalNode FIRST() { return getToken(SearchExprs.FIRST, 0); }
		public TerminalNode FIRST_VALUE() { return getToken(SearchExprs.FIRST_VALUE, 0); }
		public TerminalNode FOLLOWING() { return getToken(SearchExprs.FOLLOWING, 0); }
		public TerminalNode HOURS() { return getToken(SearchExprs.HOURS, 0); }
		public TerminalNode IDENTITY_VALUE() { return getToken(SearchExprs.IDENTITY_VALUE, 0); }
		public TerminalNode INIT() { return getToken(SearchExprs.INIT, 0); }
		public TerminalNode INT() { return getToken(SearchExprs.INT, 0); }
		public TerminalNode LAST() { return getToken(SearchExprs.LAST, 0); }
		public TerminalNode LAST_VALUE() { return getToken(SearchExprs.LAST_VALUE, 0); }
		public TerminalNode LOW() { return getToken(SearchExprs.LOW, 0); }
		public TerminalNode MAX() { return getToken(SearchExprs.MAX, 0); }
		public TerminalNode MIN() { return getToken(SearchExprs.MIN, 0); }
		public TerminalNode MINUTES() { return getToken(SearchExprs.MINUTES, 0); }
		public TerminalNode NUMBER() { return getToken(SearchExprs.NUMBER, 0); }
		public TerminalNode ROW() { return getToken(SearchExprs.ROW, 0); }
		public TerminalNode ROW_NUMBER() { return getToken(SearchExprs.ROW_NUMBER, 0); }
		public TerminalNode ROWCOUNT() { return getToken(SearchExprs.ROWCOUNT, 0); }
		public TerminalNode SUM() { return getToken(SearchExprs.SUM, 0); }
		public TerminalNode TIME() { return getToken(SearchExprs.TIME, 0); }
		public IdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_id; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).enterId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof SearchExprsListener ) ((SearchExprsListener)listener).exitId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof SearchExprsVisitor ) return ((SearchExprsVisitor<? extends T>)visitor).visitId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final IdContext id() throws RecognitionException {
		IdContext _localctx = new IdContext(_ctx, getState());
		enterRule(_localctx, 38, RULE_id);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(249);
			_la = _input.LA(1);
			if ( !(_la==INIT || _la==ROWCOUNT || ((((_la - 396)) & ~0x3f) == 0 && ((1L << (_la - 396)) & ((1L << (AGGREGATE - 396)) | (1L << (AVG - 396)) | (1L << (BIGINT - 396)) | (1L << (BINARY_BASE64 - 396)) | (1L << (COUNT - 396)) | (1L << (COUNT_BIG - 396)) | (1L << (COUNTER - 396)))) != 0) || ((((_la - 460)) & ~0x3f) == 0 && ((1L << (_la - 460)) & ((1L << (DATEADD - 460)) | (1L << (DATEDIFF - 460)) | (1L << (DATENAME - 460)) | (1L << (DATEPART - 460)) | (1L << (DAYS - 460)) | (1L << (FIRST - 460)) | (1L << (FIRST_VALUE - 460)) | (1L << (FOLLOWING - 460)))) != 0) || ((((_la - 537)) & ~0x3f) == 0 && ((1L << (_la - 537)) & ((1L << (HOURS - 537)) | (1L << (IDENTITY_VALUE - 537)) | (1L << (INT - 537)) | (1L << (LAST - 537)) | (1L << (LAST_VALUE - 537)) | (1L << (LOW - 537)) | (1L << (MAX - 537)) | (1L << (MIN - 537)) | (1L << (MINUTES - 537)))) != 0) || _la==NUMBER || ((((_la - 697)) & ~0x3f) == 0 && ((1L << (_la - 697)) & ((1L << (ROW - 697)) | (1L << (ROW_NUMBER - 697)) | (1L << (SUM - 697)) | (1L << (TIME - 697)))) != 0) || _la==ID) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 5:
			return expression_sempred((ExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private boolean expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0:
			return precpred(_ctx, 5);
		case 1:
			return precpred(_ctx, 4);
		case 2:
			return precpred(_ctx, 3);
		case 3:
			return precpred(_ctx, 2);
		}
		return true;
	}

	public static final String _serializedATN =
		"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0345\u00fe\4\2\t"+
		"\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13"+
		"\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22"+
		"\4\23\t\23\4\24\t\24\4\25\t\25\3\2\3\2\3\2\7\2.\n\2\f\2\16\2\61\13\2\3"+
		"\3\3\3\3\3\7\3\66\n\3\f\3\16\39\13\3\3\4\5\4<\n\4\3\4\3\4\3\5\3\5\3\5"+
		"\3\5\3\5\3\5\5\5F\n\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5O\n\5\3\5\3\5\3\5"+
		"\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5\\\n\5\3\6\3\6\3\6\7\6a\n\6\f\6\16"+
		"\6d\13\6\3\7\3\7\3\7\3\7\3\7\3\7\5\7l\n\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7"+
		"\3\7\3\7\3\7\3\7\3\7\3\7\3\7\7\7|\n\7\f\7\16\7\177\13\7\3\b\3\b\3\b\3"+
		"\b\5\b\u0085\n\b\3\b\3\b\5\b\u0089\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t"+
		"\3\t\5\t\u0094\n\t\3\t\5\t\u0097\n\t\3\n\3\n\3\13\3\13\3\13\5\13\u009e"+
		"\n\13\3\13\3\13\3\f\3\f\3\f\5\f\u00a5\n\f\3\f\3\f\3\f\3\f\3\f\5\f\u00ac"+
		"\n\f\3\f\3\f\3\f\3\f\5\f\u00b2\n\f\3\f\3\f\3\f\3\f\3\f\5\f\u00b9\n\f\3"+
		"\f\5\f\u00bc\n\f\3\r\3\r\3\r\3\r\5\r\u00c2\n\r\3\16\3\16\3\16\3\16\3\17"+
		"\3\17\3\17\3\17\3\17\3\17\3\17\5\17\u00cf\n\17\3\20\3\20\3\20\3\20\3\20"+
		"\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20"+
		"\3\20\5\20\u00e5\n\20\3\21\3\21\3\22\5\22\u00ea\n\22\3\22\3\22\3\23\3"+
		"\23\3\23\5\23\u00f1\n\23\3\23\3\23\5\23\u00f5\n\23\3\23\5\23\u00f8\n\23"+
		"\3\24\3\24\3\25\3\25\3\25\2\3\f\26\2\4\6\b\n\f\16\20\22\24\26\30\32\34"+
		"\36 \"$&(\2\n\3\2\u033c\u033e\5\2\u0331\u0331\u033f\u0340\u0342\u0344"+
		"\b\2\u01a5\u01a5\u0244\u0244\u0254\u0254\u02e1\u02e2\u02e6\u02e6\u0307"+
		"\u0308\3\2\u01c3\u01c4\3\2\u033f\u0340\3\2\u0329\u0330\3\2\u0323\u0324"+
		"\26\2\u00a0\u00a0\u0124\u0124\u018e\u018e\u01a5\u01a5\u01a8\u01a9\u01c3"+
		"\u01c5\u01ce\u01d2\u0204\u0206\u021b\u021c\u0227\u0227\u0232\u0233\u0240"+
		"\u0240\u0244\u0244\u0254\u0254\u0259\u0259\u0272\u0272\u02bb\u02bc\u02e6"+
		"\u02e6\u02f1\u02f1\u031e\u031e\2\u011c\2*\3\2\2\2\4\62\3\2\2\2\6;\3\2"+
		"\2\2\b[\3\2\2\2\n]\3\2\2\2\fk\3\2\2\2\16\u0088\3\2\2\2\20\u0096\3\2\2"+
		"\2\22\u0098\3\2\2\2\24\u009d\3\2\2\2\26\u00bb\3\2\2\2\30\u00c1\3\2\2\2"+
		"\32\u00c3\3\2\2\2\34\u00ce\3\2\2\2\36\u00e4\3\2\2\2 \u00e6\3\2\2\2\"\u00e9"+
		"\3\2\2\2$\u00f7\3\2\2\2&\u00f9\3\2\2\2(\u00fb\3\2\2\2*/\5\4\3\2+,\7\u00ef"+
		"\2\2,.\5\4\3\2-+\3\2\2\2.\61\3\2\2\2/-\3\2\2\2/\60\3\2\2\2\60\3\3\2\2"+
		"\2\61/\3\2\2\2\62\67\5\6\4\2\63\64\7\13\2\2\64\66\5\6\4\2\65\63\3\2\2"+
		"\2\669\3\2\2\2\67\65\3\2\2\2\678\3\2\2\28\5\3\2\2\29\67\3\2\2\2:<\7\u00de"+
		"\2\2;:\3\2\2\2;<\3\2\2\2<=\3\2\2\2=>\5\b\5\2>\7\3\2\2\2?@\5\f\7\2@A\5"+
		"\36\20\2AB\5\f\7\2B\\\3\2\2\2CE\5\f\7\2DF\7\u00de\2\2ED\3\2\2\2EF\3\2"+
		"\2\2FG\3\2\2\2GH\7\u009b\2\2HI\7\u0337\2\2IJ\5\n\6\2JK\7\u0338\2\2K\\"+
		"\3\2\2\2LN\5\f\7\2MO\7\u00de\2\2NM\3\2\2\2NO\3\2\2\2OP\3\2\2\2PQ\7\u00b4"+
		"\2\2QR\5\f\7\2R\\\3\2\2\2ST\5\f\7\2TU\7\u00a8\2\2UV\5\"\22\2V\\\3\2\2"+
		"\2WX\7\u0337\2\2XY\5\2\2\2YZ\7\u0338\2\2Z\\\3\2\2\2[?\3\2\2\2[C\3\2\2"+
		"\2[L\3\2\2\2[S\3\2\2\2[W\3\2\2\2\\\t\3\2\2\2]b\5\f\7\2^_\7\u0339\2\2_"+
		"a\5\f\7\2`^\3\2\2\2ad\3\2\2\2b`\3\2\2\2bc\3\2\2\2c\13\3\2\2\2db\3\2\2"+
		"\2ef\b\7\1\2fl\5\16\b\2gl\5\24\13\2hl\5\32\16\2il\5\30\r\2jl\5\34\17\2"+
		"ke\3\2\2\2kg\3\2\2\2kh\3\2\2\2ki\3\2\2\2kj\3\2\2\2l}\3\2\2\2mn\f\7\2\2"+
		"no\t\2\2\2o|\5\f\7\bpq\f\6\2\2qr\t\3\2\2r|\5\f\7\7st\f\5\2\2tu\5\36\20"+
		"\2uv\5\f\7\6v|\3\2\2\2wx\f\4\2\2xy\5 \21\2yz\5\f\7\5z|\3\2\2\2{m\3\2\2"+
		"\2{p\3\2\2\2{s\3\2\2\2{w\3\2\2\2|\177\3\2\2\2}{\3\2\2\2}~\3\2\2\2~\r\3"+
		"\2\2\2\177}\3\2\2\2\u0080\u0089\5\20\t\2\u0081\u0082\5\22\n\2\u0082\u0084"+
		"\7\u0337\2\2\u0083\u0085\5\n\6\2\u0084\u0083\3\2\2\2\u0084\u0085\3\2\2"+
		"\2\u0085\u0086\3\2\2\2\u0086\u0087\7\u0338\2\2\u0087\u0089\3\2\2\2\u0088"+
		"\u0080\3\2\2\2\u0088\u0081\3\2\2\2\u0089\17\3\2\2\2\u008a\u008b\t\4\2"+
		"\2\u008b\u008c\7\u0337\2\2\u008c\u008d\5\24\13\2\u008d\u008e\7\u0338\2"+
		"\2\u008e\u0097\3\2\2\2\u008f\u0090\t\5\2\2\u0090\u0093\7\u0337\2\2\u0091"+
		"\u0094\7\u033c\2\2\u0092\u0094\5\24\13\2\u0093\u0091\3\2\2\2\u0093\u0092"+
		"\3\2\2\2\u0094\u0095\3\2\2\2\u0095\u0097\7\u0338\2\2\u0096\u008a\3\2\2"+
		"\2\u0096\u008f\3\2\2\2\u0097\21\3\2\2\2\u0098\u0099\5(\25\2\u0099\23\3"+
		"\2\2\2\u009a\u009b\5\26\f\2\u009b\u009c\7\u0332\2\2\u009c\u009e\3\2\2"+
		"\2\u009d\u009a\3\2\2\2\u009d\u009e\3\2\2\2\u009e\u009f\3\2\2\2\u009f\u00a0"+
		"\5(\25\2\u00a0\25\3\2\2\2\u00a1\u00a2\5(\25\2\u00a2\u00a4\7\u0332\2\2"+
		"\u00a3\u00a5\5(\25\2\u00a4\u00a3\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a6"+
		"\3\2\2\2\u00a6\u00a7\7\u0332\2\2\u00a7\u00ac\3\2\2\2\u00a8\u00a9\5(\25"+
		"\2\u00a9\u00aa\7\u0332\2\2\u00aa\u00ac\3\2\2\2\u00ab\u00a1\3\2\2\2\u00ab"+
		"\u00a8\3\2\2\2\u00ab\u00ac\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad\u00bc\5("+
		"\25\2\u00ae\u00af\5(\25\2\u00af\u00b1\7\u0332\2\2\u00b0\u00b2\5(\25\2"+
		"\u00b1\u00b0\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b3\3\2\2\2\u00b3\u00b4"+
		"\7\u0332\2\2\u00b4\u00b9\3\2\2\2\u00b5\u00b6\5(\25\2\u00b6\u00b7\7\u0332"+
		"\2\2\u00b7\u00b9\3\2\2\2\u00b8\u00ae\3\2\2\2\u00b8\u00b5\3\2\2\2\u00b8"+
		"\u00b9\3\2\2\2\u00b9\u00ba\3\2\2\2\u00ba\u00bc\7 \2\2\u00bb\u00ab\3\2"+
		"\2\2\u00bb\u00b8\3\2\2\2\u00bc\27\3\2\2\2\u00bd\u00be\7\u0341\2\2\u00be"+
		"\u00c2\5\f\7\2\u00bf\u00c0\t\6\2\2\u00c0\u00c2\5\f\7\2\u00c1\u00bd\3\2"+
		"\2\2\u00c1\u00bf\3\2\2\2\u00c2\31\3\2\2\2\u00c3\u00c4\7\u0337\2\2\u00c4"+
		"\u00c5\5\f\7\2\u00c5\u00c6\7\u0338\2\2\u00c6\33\3\2\2\2\u00c7\u00cf\7"+
		"\u00e1\2\2\u00c8\u00cf\5$\23\2\u00c9\u00cf\5\16\b\2\u00ca\u00cb\7\u0337"+
		"\2\2\u00cb\u00cc\5\34\17\2\u00cc\u00cd\7\u0338\2\2\u00cd\u00cf\3\2\2\2"+
		"\u00ce\u00c7\3\2\2\2\u00ce\u00c8\3\2\2\2\u00ce\u00c9\3\2\2\2\u00ce\u00ca"+
		"\3\2\2\2\u00cf\35\3\2\2\2\u00d0\u00e5\7\u0325\2\2\u00d1\u00e5\7\u0326"+
		"\2\2\u00d2\u00e5\7\u0327\2\2\u00d3\u00d4\7\u0327\2\2\u00d4\u00e5\7\u0325"+
		"\2\2\u00d5\u00d6\7\u0326\2\2\u00d6\u00e5\7\u0325\2\2\u00d7\u00d8\7\u0327"+
		"\2\2\u00d8\u00e5\7\u0326\2\2\u00d9\u00da\7\u0328\2\2\u00da\u00e5\7\u0325"+
		"\2\2\u00db\u00dc\7\u0328\2\2\u00dc\u00e5\7\u0326\2\2\u00dd\u00de\7\u0328"+
		"\2\2\u00de\u00e5\7\u0327\2\2\u00df\u00e0\7\u033e\2\2\u00e0\u00e5\7\u0341"+
		"\2\2\u00e1\u00e5\7\u033e\2\2\u00e2\u00e3\7\u0341\2\2\u00e3\u00e5\7\u033e"+
		"\2\2\u00e4\u00d0\3\2\2\2\u00e4\u00d1\3\2\2\2\u00e4\u00d2\3\2\2\2\u00e4"+
		"\u00d3\3\2\2\2\u00e4\u00d5\3\2\2\2\u00e4\u00d7\3\2\2\2\u00e4\u00d9\3\2"+
		"\2\2\u00e4\u00db\3\2\2\2\u00e4\u00dd\3\2\2\2\u00e4\u00df\3\2\2\2\u00e4"+
		"\u00e1\3\2\2\2\u00e4\u00e2\3\2\2\2\u00e5\37\3\2\2\2\u00e6\u00e7\t\7\2"+
		"\2\u00e7!\3\2\2\2\u00e8\u00ea\7\u00de\2\2\u00e9\u00e8\3\2\2\2\u00e9\u00ea"+
		"\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb\u00ec\7\u00e1\2\2\u00ec#\3\2\2\2\u00ed"+
		"\u00f8\7\u0321\2\2\u00ee\u00f8\7\u0322\2\2\u00ef\u00f1\5&\24\2\u00f0\u00ef"+
		"\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1\u00f2\3\2\2\2\u00f2\u00f8\7\u031d\2"+
		"\2\u00f3\u00f5\5&\24\2\u00f4\u00f3\3\2\2\2\u00f4\u00f5\3\2\2\2\u00f5\u00f6"+
		"\3\2\2\2\u00f6\u00f8\t\b\2\2\u00f7\u00ed\3\2\2\2\u00f7\u00ee\3\2\2\2\u00f7"+
		"\u00f0\3\2\2\2\u00f7\u00f4\3\2\2\2\u00f8%\3\2\2\2\u00f9\u00fa\t\6\2\2"+
		"\u00fa\'\3\2\2\2\u00fb\u00fc\t\t\2\2\u00fc)\3\2\2\2\35/\67;EN[bk{}\u0084"+
		"\u0088\u0093\u0096\u009d\u00a4\u00ab\u00b1\u00b8\u00bb\u00c1\u00ce\u00e4"+
		"\u00e9\u00f0\u00f4\u00f7";
	public static final ATN _ATN =
		new ATNDeserializer().deserialize(_serializedATN.toCharArray());
	static {
		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
		for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
		}
	}
}